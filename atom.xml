<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://guanxuchao.com/</id>
    <title>Chao&apos;s Blog</title>
    <updated>2019-11-20T07:26:07.701Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://guanxuchao.com/"/>
    <link rel="self" href="https://guanxuchao.com//atom.xml"/>
    <subtitle>&lt;h4&gt;个人技术博客&lt;/h4&gt;</subtitle>
    <logo>https://guanxuchao.com//images/avatar.png</logo>
    <icon>https://guanxuchao.com//favicon.ico</icon>
    <rights>All rights reserved 2019, Chao&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[谷歌VIM插件使用，键盘操作浏览器功能（带下载链接）]]></title>
        <id>https://guanxuchao.com//post/gu-ge-vim-cha-jian-shi-yong-jian-pan-cao-zuo-liu-lan-qi-gong-neng-dai-xia-zai-lian-jie</id>
        <link href="https://guanxuchao.com//post/gu-ge-vim-cha-jian-shi-yong-jian-pan-cao-zuo-liu-lan-qi-gong-neng-dai-xia-zai-lian-jie">
        </link>
        <updated>2019-11-20T06:18:10.000Z</updated>
        <summary type="html"><![CDATA[<h1>注意 vim 是严格区分大小写的</h1>
]]></summary>
        <content type="html"><![CDATA[<h1>注意 vim 是严格区分大小写的</h1>
<!-- more -->
<p>常用快捷键总结如下：<br>
j :下滚(向下移动)<br>
k :上滚(向上移动)<br>
h :向左移动<br>
l :向右移动<br>
zH :移到最左<br>
zL :移到最右<br>
gg :跳转至当前页面顶部<br>
G :跳转至当前页面底部<br>
d :向下翻页(一次滚动一个页面大小)<br>
u :向上翻页<br>
以上为当前页移动的常用命令</p>
<p>x :关闭当前页(等同 ctrl+w)<br>
X :回滚(恢复刚刚关闭的页面 很实用)<br>
r :重新载入当前页(等同 F5)<br>
t :打开新标签页(等同Ctrl+t)<br>
T :打开全部已有的标签页并选择进行回车跳转(非常实用)<br>
K :跳转到右边的标签(紧邻的跳转) 也可使用 gt<br>
J :跳转到左边的标签 也可使用 gT<br>
W :单独窗口打开(打开对象使用字母编号选择 注意是大写W)<br>
f :在当前页面打开一个新连接(会自动出现字母组合的索引自行选择)<br>
F :在新页面打开连接<br>
b :在当前页面打开一个书签(手动输入网址或连接地址)<br>
B :在新页面打开(同样手动输入)<br>
o :比较像 b 命令 不过这里可以匹配历史记录收藏夹等等<br>
O :同上(在新窗口中打开)<br>
以上为各个标签页跳转与开闭合命令</p>
<p>i :输入模式<br>
gi :聚焦到输入框默认第一个<br>
2gi :聚焦到第2个输入框(测试可以gi后使用Tab切到第n个换输入框)<br>
切记：输入/编辑模式后一定要按 Esc 退出才可以继续使用 vim<br>
yt :复制当前标签<br>
yy :复制当前页面的URL<br>
yf :复制某段(具体哪段 请选择前面的字母代码 区分大小写及组合)<br>
编辑操作命令</p>
<p>v :开始选择命令(可以配合jklh等移动圈选 然后p粘贴打开等操作)<br>
? :打开命令帮助提示(再次按压关闭)<br>
H :恢复到上一个历史标签页<br>
L :恢复到下一个历史标签页</p>
<p>谷歌商店下载地址：<a href="https://chrome.google.com/extensions/detail/dbepggeogbaibhgnhhndojpepiihcmeb">点击下载</a><br>
<span style="color:red">注：因为墙的原因，访问谷歌商店需要VPN</span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP笔记]]></title>
        <id>https://guanxuchao.com//post/php-xue-xi</id>
        <link href="https://guanxuchao.com//post/php-xue-xi">
        </link>
        <updated>2019-10-16T02:24:29.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<h2 id="php基础">PHP基础</h2>
<ol>
<li>
<h4 id="变量规则">变量规则</h4>
<ol>
<li>变量以 $ 符号开头，其后是变量的名称</li>
<li>变量名称必须以字母或下划线开头</li>
<li>变量名称不能以数字开头</li>
<li>变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）</li>
<li>变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）</li>
<li>PHP 没有创建变量的命令，变量会在首次为其赋值时被创建
<ol>
<li>PHP 是一门类型松散的语言，我们不必告知 PHP 变量的数据类型；PHP 根据它的值，自动把变量转换为正确的数据类型；在诸如 C 和 C++ 以及 Java 之类的语言中，程序员必须在使用变量之前声明它的名称和类型。</li>
</ol>
</li>
</ol>
</li>
<li>
<h4 id="变量作用域">变量作用域</h4>
<ol>
<li>在 PHP 中，可以在脚本的任意位置对变量进行声明，变量的作用域指的是变量能够被引用/使用的那部分脚本。</li>
<li>PHP 有三种不同的变量作用域：
<ol>
<li><strong>local（局部）</strong>
<ol>
<li>函数内部声明的变量拥有 LOCAL 作用域，只能在函数内部进行访问</li>
</ol>
</li>
<li><strong>global（全局）</strong>
<ol>
<li>函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问</li>
</ol>
</li>
<li><strong>static（静态）</strong>
<ol>
<li>通常，当函数完成/执行后，会删除所有变量。不过，有时我需要不删除某个局部变量。实现这一点需要更进一步的工作；要完成这一点，请在您首次声明变量时使用 static 关键词</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<h4 id="echo-和-print-语句">echo 和 print 语句</h4>
<ol>
<li><strong>echo 和 print 之间的差异</strong>
<ol>
<li>echo - 能够输出一个以上的字符串。</li>
<li>print - 只能输出一个字符串，并始终返回 1。</li>
<li>echo 比 print 稍快，因为它不返回任何值。</li>
</ol>
</li>
<li><strong>echo 语句:</strong>
<ol>
<li>echo 是一个语言结构，有无括号均可使用：echo 或 echo()。</li>
</ol>
</li>
<li><strong>print 语句:</strong>
<ol>
<li>print 也是语言结构，有无括号均可使用：print 或 print()。</li>
</ol>
</li>
</ol>
</li>
<li>
<h4 id="数据类型">数据类型</h4>
<ol>
<li><strong>字符串:</strong>
<ol>
<li>字符串是字符序列，比如 &quot;Hello world!&quot;;字符串可以是引号内的任何文本。您可以使用单引号或双引号</li>
</ol>
</li>
<li><strong>整数:</strong>
<ol>
<li>整数是没有小数的数字。</li>
<li>整数必须有至少一个数字（0-9）</li>
<li>整数不能包含逗号或空格</li>
<li>整数不能有小数点</li>
<li>整数正负均可</li>
<li>可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0）</li>
<li><strong>var_dump()</strong> 会返回变量的数据类型和值</li>
</ol>
</li>
<li><strong>浮点数：</strong>
<ol>
<li>浮点数是有小数点或指数形式的数字。</li>
</ol>
</li>
<li><strong>逻辑：</strong>
<ol>
<li>逻辑是 true 或 false。</li>
</ol>
</li>
<li><strong>数组：</strong>
<ol>
<li>数组在一个变量中存储多个值。</li>
</ol>
</li>
<li><strong>NULL 值：</strong>
<ol>
<li>特殊的 NULL 值表示变量无值。NULL 是数据类型 NULL 唯一可能的值。</li>
<li>NULL 值标示变量是否为空。也用于区分空字符串与空值数据库。</li>
<li>可以通过把值设置为 NULL，将变量清空。</li>
</ol>
</li>
</ol>
</li>
<li>
<h4 id="字符串函数">字符串函数：</h4>
<ol>
<li><strong>strlen() 函数：</strong>
<ol>
<li>strlen() 函数返回字符串的长度，以字符计。</li>
<li>strlen() 常用于循环和其他函数，在确定字符串何时结束很重要时。（例如，在循环中，我们也许需要在字符串的最后一个字符之后停止循环）。</li>
</ol>
</li>
<li><strong>对字符串中的单词计数：</strong>
<ol>
<li>str_word_count() 函数对字符串中的单词进行计数（空格相隔）</li>
</ol>
</li>
<li><strong>反转字符串：</strong>
<ol>
<li>strrev() 函数反转字符串</li>
</ol>
</li>
<li><strong>strpos() 函数：</strong>
<ol>
<li>strpos() 函数用于检索字符串内指定的字符或文本。</li>
<li>如果找到匹配，则会返回首个匹配的字符位置。如果未找到匹配，则将返回 FALSE。</li>
</ol>
</li>
<li><strong>替换字符串中的文本：</strong>
<ol>
<li>str_replace() 函数用一些字符串替换字符串中的另一些字符。</li>
</ol>
</li>
</ol>
</li>
<li>
<h4 id="常量">常量</h4>
<ol>
<li><strong>常量：</strong>
<ol>
<li>常量是单个值的标识符（名称）。在脚本中无法改变该值。</li>
<li>有效的常量名以字符或下划线开头（常量名称前面没有 $ 符号）。</li>
<li>与变量不同，<strong>常量贯穿整个脚本</strong>是<strong>自动全局</strong>的。</li>
</ol>
</li>
<li><strong>设置常量：</strong>
<ol>
<li>如需设置常量，请使用 define() 函数 - 它使用三个参数：
<ol>
<li>首个参数定义常量的名称</li>
<li>第二个参数定义常量的值</li>
<li>可选的第三个参数规定常量名是否对大小写不敏感。默认是 false。</li>
</ol>
</li>
</ol>
</li>
<li><strong>魔术常量：</strong>
<ol>
<li>PHP 向它运行的任何脚本提供了大量的预定义常量，命名规则(<code>__函数名__</code>)。</li>
<li>不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。</li>
<li>有八个魔术常量它们的值随着它们在代码中的位置改变而改变。</li>
<li><strong><strong>LINE</strong>：</strong>
<ol>
<li>当前所属行数</li>
</ol>
</li>
<li><strong><strong>FILE</strong>：</strong>
<ol>
<li>当前被执行的脚本所在的电脑的绝对路径（带自己文件的名字）</li>
</ol>
</li>
<li><strong><strong>DIR</strong>：</strong>
<ol>
<li>当前被执行的脚本所在的电脑的绝对路径</li>
</ol>
</li>
<li><strong><strong>FUNCTION</strong>：</strong>
<ol>
<li>返回该函数被定义时的名字（区分大小写）</li>
</ol>
</li>
<li><strong><strong>CLASS</strong>：</strong>
<ol>
<li>返回该类被定义时的名字（区分大小写）</li>
</ol>
</li>
<li><strong><strong>TRAIT</strong>：</strong>
<ol>
<li>实现了代码复用</li>
</ol>
</li>
<li><strong><strong>METHOD</strong>：</strong>
<ol>
<li>返回所属方法被定义时的名字（区分大小写）</li>
</ol>
</li>
<li><strong><strong>NAMESPACE</strong>：</strong>
<ol>
<li>当前命名空间的名称（区分大小写）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<h4 id="运算符">运算符</h4>
<ol>
<li><strong>算数运算符:</strong><br><br>
<img src="https://guanxuchao.com//post-images/1571195274275.jpg" alt=""></li>
<li><strong>赋值运算符:</strong><br><br>
<img src="https://guanxuchao.com//post-images/1571195313239.jpg" alt=""></li>
<li><strong>字符串运算符:</strong><br><br>
<img src="https://guanxuchao.com//post-images/1571195322387.jpg" alt=""></li>
<li><strong>递增/递减运算符:</strong><br><br>
<img src="https://guanxuchao.com//post-images/1571195331668.jpg" alt=""></li>
<li><strong>比较运算符:</strong><br><br>
<img src="https://guanxuchao.com//post-images/1571195344246.jpg" alt=""></li>
<li><strong>逻辑运算符:</strong><br><br>
<img src="https://guanxuchao.com//post-images/1571195355838.jpg" alt=""></li>
<li><strong>数组运算符:</strong><br><br>
<img src="https://guanxuchao.com//post-images/1571195362828.jpg" alt=""></li>
</ol>
</li>
<li>
<h4 id="条件语句">条件语句</h4>
<ol>
<li><strong>if 语句</strong> - 如果指定条件为真，则执行代码
<ol>
<li>if 语句用于<strong>在指定条件为 true 时</strong>执行代码。</li>
</ol>
</li>
<li><strong>if...else 语句</strong> - 如果条件为 true，则执行代码；如果条件为 false，则执行另一端代码
<ol>
<li>if....else 语句<strong>在条件为 true 时执行代码，在条件为 false 时执行另一段代码</strong>。</li>
</ol>
</li>
<li><strong>if...elseif....else 语句</strong> - 根据两个以上的条件执行不同的代码块
<ol>
<li>if....elseif...else 语句来<strong>根据两个以上的条件执行不同的代码</strong>。</li>
</ol>
</li>
<li><strong>switch 语句</strong> - 选择多个代码块之一来执行
<ol>
<li>当希望<strong>有选择地执行若干代码块之一</strong>，请使用 Switch 语句。</li>
<li>使用 Switch 语句可以避免冗长的 if..elseif..else 代码块。</li>
</ol>
</li>
</ol>
</li>
<li>
<h4 id="循环">循环</h4>
<ol>
<li><strong>while:</strong>- 只要指定条件为真，则循环代码块
<ol>
<li><code>while (条件为真) {要执行的代码;}</code></li>
</ol>
</li>
<li><strong>do...while:</strong> - 先执行一次代码块，然后只要指定条件为真则重复循环
<ol>
<li><code>do {要执行的代码;} while (条件为真);</code></li>
</ol>
</li>
<li><strong>for:</strong> - 循环代码块指定次数
<ol>
<li><code>for (init counter; test counter; increment counter) {code to be executed;}</code>
<ol>
<li>init counter：初始化循环计数器的值</li>
<li>test counter：: 评估每个循环迭代。如果值为 TRUE，继续循环。如果它的值为 FALSE，循环结束。</li>
<li>increment counter：增加循环计数器的值</li>
</ol>
</li>
</ol>
</li>
<li><strong>for each:</strong>- 遍历数组中的每个元素并循环代码块
<ol>
<li>foreach 循环只适用于<strong>数组</strong>，并用于遍历数组中的每个键/值对。</li>
<li><code>foreach ($array as $value) {code to be executed;}</code></li>
</ol>
</li>
</ol>
</li>
<li>
<h3 id="函数">函数</h3>
<ol>
<li>PHP 的真正力量来自它的函数：它拥有超过 1000 个内建的函数。</li>
<li><strong>用户定义函数</strong>
<ol>
<li>除了内建的 PHP 函数，我们可以创建我们自己的函数。</li>
<li>函数是可以在程序中重复使用的语句块。</li>
<li>页面加载时函数不会立即执行。</li>
<li>函数只有在被调用时才会执行。</li>
</ol>
</li>
<li><strong>创建用户定义函数：</strong>
<ol>
<li>用户定义的函数声明以单词 &quot;function&quot; 开头：
<ol>
<li><code>function functionName() {被执行的代码;}</code></li>
</ol>
</li>
<li>函数名能够以字母或下划线开头（而非数字）。</li>
<li>函数名对大小写不敏感。</li>
<li>函数名应该能够反映函数所执行的任务。</li>
<li>如需调用该函数，只要使用函数名即可</li>
</ol>
</li>
<li><strong>函数参数：</strong>
<ol>
<li>可以通过参数向函数传递信息。参数类似变量。</li>
<li>参数被定义在函数名之后，括号内部。您可以添加任意多参数，只要用逗号隔开即可。</li>
</ol>
</li>
<li><strong>默认参数值：</strong>
<ol>
<li>可以给参数设置默认值，当调用没有参数的函数时，它的参数会取默认值</li>
</ol>
</li>
<li><strong>函数 - 返回值：</strong>
<ol>
<li>如需使函数返回值，可以使用 return 语句</li>
</ol>
</li>
</ol>
</li>
<li>
<h3 id="数组">数组</h3>
<ol>
<li>数组能够在单独的变量名中存储一个或多个值。数组是特殊的变量，它可以同时保存一个以上的值。</li>
<li><strong>创建数组:</strong>
<ol>
<li>在 PHP 中， array() 函数用于创建数组：</li>
</ol>
</li>
<li><strong>数组类型：</strong>
<ol>
<li><strong>索引数组</strong> - 带有数字索引的数组
<ol>
<li>有两种创建索引数组的方法：
<ol>
<li>索引自动分配（索引从0开始）
<ol>
<li><code>$cars=array(&quot;porsche&quot;,&quot;BMW&quot;,&quot;Volvo&quot;);</code></li>
</ol>
</li>
<li>手动分配索引
<ol>
<li><code>$cars[0]=&quot;porsche&quot;;$cars[1]=&quot;BMW&quot;;$cars[2]=&quot;Volvo&quot;;</code></li>
</ol>
</li>
</ol>
</li>
<li>获得数组的长度 - count() 函数
<ol>
<li>count(数组名) 函数用于返回数组的长度（元素数）</li>
</ol>
</li>
<li>遍历索引数组
<ol>
<li>利用for循环和 count()函数 遍历数组</li>
</ol>
</li>
</ol>
</li>
<li><strong>关联数组</strong> - 带有指定键的数组
<ol>
<li>关联数组是使用您分配给数组的指定键的数组。(类似于key value)</li>
<li>有两种创建关联数组的方法：
<ol>
<li><code>$age=array(&quot;Bill&quot;=&gt;&quot;35&quot;,&quot;Steve&quot;=&gt;&quot;37&quot;,&quot;Elon&quot;=&gt;&quot;43&quot;);</code></li>
<li><code>$age['Bill']=&quot;63&quot;;$age['Steve']=&quot;56&quot;;$age['Elon']=&quot;47&quot;;</code></li>
</ol>
</li>
<li>遍历关联数组
<ol>
<li>利用 foreach 循环：</li>
<li><code>$age=array(&quot;Bill&quot;=&gt;&quot;63&quot;,&quot;Steve&quot;=&gt;&quot;56&quot;,&quot;Elon&quot;=&gt;&quot;47&quot;);</code><br><code>foreach($age as $x=&gt;$x_value) {echo &quot;Key=&quot; . $x . &quot;, Value=&quot; . $x_value;echo &quot;&lt;br&gt;&quot;;}</code></li>
</ol>
</li>
</ol>
</li>
<li><strong>多维数组</strong> - 包含一个或多个数组的数组</li>
</ol>
</li>
</ol>
</li>
<li>
<h4 id="数组排序">数组排序</h4>
<ol>
<li><strong>数组的排序函数：</strong>
<ol>
<li><strong>对数组进行升序排序 - sort()：</strong>
<ol>
<li>**sort(数组名)：**可按照字母和数字进行升序(A-Z,0-9)</li>
</ol>
</li>
<li><strong>对数组进行降序排序 - rsort()：</strong>
<ol>
<li>**rsort(数组名)：**可按照字母和数字进行升序(Z-A,9-0)</li>
</ol>
</li>
<li><strong>根据值对数组进行升序排序 - asort()：</strong>
<ol>
<li>**asort(数组名)：**根据值的大小对关联数组进行升序排序</li>
</ol>
</li>
<li><strong>根据键对数组进行升序排序 - ksort()：</strong>
<ol>
<li>**ksort(数组名)：**根据键的字母顺序对关联数组进行升序排序</li>
</ol>
</li>
<li><strong>根据值对数组进行降序排序 - arsort()：</strong>
<ol>
<li>**arsort(数组名)：**根据值的大小对关联数组进行降序排序</li>
</ol>
</li>
<li><strong>根据键对数组进行降序排序 - krsort()：</strong>
<ol>
<li>**krsort(数组名)：**根据键的字母顺序对关联数组进行降序排序</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<h4 id="全局变量-超全局变量">全局变量 - 超全局变量</h4>
<ol>
<li>超全局变量在 PHP 4.1.0 中引入，是在全部作用域中始终可用的内置变量。</li>
<li><strong>全局变量 - 超全局变量：</strong>
<ol>
<li>PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们。</li>
<li><strong>$GLOBALS — 引用全局作用域中可用的全部变量：</strong>
<ol>
<li>$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。</li>
<li>PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。</li>
</ol>
</li>
<li><strong>$_SERVER：</strong>
<ol>
<li>$_SERVER 这种超全局变量保存关于报头、路径和脚本位置的信息。<br><br>
<img src="https://guanxuchao.com//post-images/1571195392541.jpg" alt=""></li>
</ol>
</li>
<li><strong>$_REQUEST：</strong>
<ol>
<li>$_REQUEST 用于收集 HTML 表单提交的数据。</li>
</ol>
</li>
<li><strong>$_POST：</strong>
<ol>
<li><code>$_POST</code> 广泛用于收集提交 method=&quot;post&quot; 的 HTML 表单后的表单数据。$_POST 也常用于传递变量。</li>
</ol>
</li>
<li><strong>$_GET：</strong>
<ol>
<li>$_GET 也可用于收集提交 HTML 表单 (method=&quot;get&quot;) 之后的表单数据。</li>
<li>$_GET 也可以收集 URL 中的发送的数据。</li>
</ol>
</li>
<li><strong>：</strong></li>
<li><strong>：</strong></li>
<li><strong>：</strong></li>
<li><strong>：</strong></li>
</ol>
</li>
</ol>
</li>
<li>
<h4 id="表单处理">表单处理</h4>
</li>
<li>
<p><strong>一个简单的 HTML 表单:</strong></p>
<ol>
<li>下面的例子显示了一个简单的 HTML 表单，它包含两个输入字段和一个提交按钮：<br><br>
<img src="https://guanxuchao.com//post-images/1571195429149.jpg" alt=""><br><br>
当用户填写此表单并点击提交按钮后，表单数据会发送到名为 &quot;welcome.php&quot; 的 PHP 文件供处理。表单数据是通过 HTTP POST 方法发送的。<br><br>
如需显示出被提交的数据，您可以简单地输出（echo）所有变量。&quot;welcome.php&quot; 文件是这样的：<br><br>
<img src="https://guanxuchao.com//post-images/1571195459828.jpg" alt=""><br><br>
输出：<br><br>
<img src="https://guanxuchao.com//post-images/1571195481676.jpg" alt=""><br><br>
使用 HTTP GET 方法也能得到相同的结果：<br><br>
<img src="https://guanxuchao.com//post-images/1571195497976.jpg" alt=""><br><br>
&quot;welcome_get.php&quot; 是这样的：<br><br>
<img src="https://guanxuchao.com//post-images/1571195506897.jpg" alt=""><br></li>
<li><strong>上面的代码很简单。不过，最重要的内容被漏掉了。需要对表单数据进行验证，以防止脚本出现漏洞。</strong></li>
</ol>
</li>
<li>
<p><strong>GET vs. POST:</strong></p>
<ol>
<li>GET 和 POST 都创建数组（例如，array( key =&gt; value, key2 =&gt; value2, key3 =&gt; value3, ...)）。此数组包含键/值对，其中的键是表单控件的名称，而值是来自用户的输入数据。</li>
<li>GET 和 POST 被视作 $_GET 和 $_POST。它们是超全局变量，这意味着对它们的访问无需考虑作用域 - 无需任何特殊代码，您能够从任何函数、类或文件访问它们。</li>
<li>$_GET 是通过 URL 参数传递到当前脚本的变量数组。</li>
<li>$_POST 是通过 HTTP POST 传递到当前脚本的变量数组。</li>
</ol>
</li>
<li>
<p><strong>何时使用 GET？:</strong></p>
<ol>
<li>通过 GET 方法从表单发送的信息<strong>对任何人都是可见的</strong>（所有变量名和值都显示在 URL 中）。GET 对所发送信息的数量也有限制。限制在大约 2000 个字符。不过，由于变量显示在 URL 中，把页面添加到书签中也更为方便。</li>
<li>GET 可用于发送非敏感的数据。</li>
<li><strong>绝不能使用 GET 来发送密码或其他敏感信息！</strong></li>
</ol>
</li>
<li>
<p><strong>何时使用 POST？:</strong></p>
<ol>
<li>通过 POST 方法从表单发送的信息<strong>对其他人是不可见的</strong>（所有名称/值会被嵌入 HTTP 请求的主体中），并且对所发送信息的数量也<strong>无限制</strong>。</li>
<li>此外 POST 支持高阶功能，比如在向服务器上传文件时进行 multi-part 二进制输入。</li>
<li>不过，由于变量未显示在 URL 中，也就无法将页面添加到书签。</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阻塞队列&二叉树]]></title>
        <id>https://guanxuchao.com//post/zu-sai-dui-lie-ander-cha-shu</id>
        <link href="https://guanxuchao.com//post/zu-sai-dui-lie-ander-cha-shu">
        </link>
        <updated>2019-08-18T07:47:45.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="1生产者-消息者模型与阻塞队列">1.生产者、消息者模型与阻塞队列</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="1生产者-消息者模型与阻塞队列">1.生产者、消息者模型与阻塞队列</h1>
<!-- more -->
<h2 id="1什么是生产者">(1)什么是生产者?</h2>
<pre><code>生产者负责产生数据。
</code></pre>
<h2 id="2什么是消费者">(2)什么是消费者?</h2>
<pre><code>消费者负责消费数据。
</code></pre>
<h2 id="3生产者-消费者模型用来解决什么问题">(3)生产者、消费者模型用来解决什么问题?</h2>
<pre><code>用来解决生产者生产数据与消费者消费数据
不同步的问题。
生产者产生数据之后，将这些数据存放到阻塞
队列里面，消息者从阻塞队列当中取出数据。
</code></pre>
<h2 id="4什么是阻塞队列">(4)什么是阻塞队列?</h2>
<pre><code>阻塞队列可以在多线程环境下使用，当阻塞队列满时，
生产者线程会阻塞（即暂时挂起)。当阻塞队列为空时，
消费者线程会阻塞。
阻塞队列一般都解决了线程安全问题。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://guanxuchao.com//post-images/1566402565227.png" alt=""></figure>
<h2 id="5生产者-消费者模型的经典使用场合">(5)生产者、消费者模型的经典使用场合</h2>
<pre><code>a.订单处理
	订单信息先写入到阻塞队列，然后消息者
	线程从阻塞队列中取出数据，写到数据库。
b.应用服务器设计(用于任务的分派)
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://guanxuchao.com//post-images/1566402579830.png" alt=""></figure>
<pre><code>c.日志
	可以让生产者线程将日志信息先写入阻塞
	队列，然后让消息者线程从阻塞队列当中取
	出日志信息，然后写入数据库。　
</code></pre>
<h2 id="6经典案例日志处理">(6)经典案例(日志处理)</h2>
<figure data-type="image" tabindex="3"><img src="https://guanxuchao.com//post-images/1566402586852.png" alt=""></figure>
<h2 id="7相关的接口与类">(7)相关的接口与类</h2>
<pre><code>BlockingQueue接口
	注：该接口继承Queue接口。
LinkedBlockingQueue类
	注：底层实现是一个链表，每添加一个消息(数据),
	就需要创建一个新的结点，如果并发量很大，
	可能会影响系统GC。
	除此之外，LinkedBlockQueue的put方法和
	take方法用的是不同的锁，并发性能比较好。
ArrayBlockingQueue类
	注：底层实现是一个数组。
	ArrayBlockingQueue的take方法和put方法
	用的是同一个锁，并发性能差一些。
</code></pre>
<h1 id="练习">练习</h1>
<pre><code>Producer线程每隔5秒向阻塞队列当中添加一个
随机数。Consumer线程每隔2秒从阻塞队列当中
取出随机数然后输出。
Producer类(Producer线程类)
Consumer类(Consumer线程类)
Test类(启动Producer线程和Consumer线程)
</code></pre>
<h1 id="2二叉树">2.二叉树</h1>
<h2 id="1什么是二叉树">(1)什么是二叉树?</h2>
<pre><code>任意一个节点，最多只有两棵子树的树结构。
注：
	这两棵子树一般称之为左子树和右子树。
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://guanxuchao.com//post-images/1566402676075.png" alt=""></figure>
<h2 id="2排序二叉树搜索二叉树">(2)排序二叉树(搜索二叉树)</h2>
<pre><code>任意一个节点，其左子树上的节点值比该节点的
值小，其右子树上的节点值比该节点的值要大。
左右子树也是一个排序二叉树。
注：
	排序二叉树不允许出现重复元素。
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://guanxuchao.com//post-images/1566402603064.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Servlet九大内置对象]]></title>
        <id>https://guanxuchao.com//post/servlet-jiu-da-nei-zhi-dui-xiang</id>
        <link href="https://guanxuchao.com//post/servlet-jiu-da-nei-zhi-dui-xiang">
        </link>
        <updated>2019-08-17T15:15:20.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">隐式对象</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">request</td>
<td style="text-align:left">转译后对应HttpServletRequest/ServletRequest对象</td>
</tr>
<tr>
<td style="text-align:left">response</td>
<td style="text-align:left">转译后对应HttpServletRespons/ServletResponse对象</td>
</tr>
<tr>
<td style="text-align:left">session</td>
<td style="text-align:left">转译后对应HttpSession对象</td>
</tr>
<tr>
<td style="text-align:left">application</td>
<td style="text-align:left">转译后对应ServletContext对象</td>
</tr>
<tr>
<td style="text-align:left">out</td>
<td style="text-align:left">转译后对应JspWriter对象，其内部关联一个PringWriter对象</td>
</tr>
<tr>
<td style="text-align:left">page</td>
<td style="text-align:left">转译后对应this</td>
</tr>
<tr>
<td style="text-align:left">config</td>
<td style="text-align:left">转译后对应ServletConfig对象</td>
</tr>
<tr>
<td style="text-align:left">pageContext</td>
<td style="text-align:left">转译后对应PageContext对象，它提供了JSP页面资源的封装，并可设置页面范围属性</td>
</tr>
<tr>
<td style="text-align:left">exception</td>
<td style="text-align:left">转译后对应Throwable对象，代表由其他JSP页面抛出的异常对象，只会出现于JSP错误页面(isErrorPage设置为true的JSP页面)</td>
</tr>
</tbody>
</table>
<h2 id="jsp隐含变量">Jsp隐含变量</h2>
<p>1、out 来源于Java.io.Writer类，它用于发送输出流到客户端。<br>
2、request 来源于javax.servlet.http.HttpServletRequest接口。它被关联到每一个HTTP请求。<br>
3、response 来源于javax.servlet.http.HttpServletResponse。response对象用于把取得的数据返回到客户端。<br>
4、pageContext 提供访问JSP页面的命名空间。它也提供用来访问其他的JSP隐含对象。<br>
5、session 来源于javax.servlet.http.HttpSession。它用于存储客户端请求的信息，因此它是有状态交互式的。<br>
6、application 来源于javax.servlet.ServletContext。<br>
7、config 来源于ServletConfig，它包含了当前JSP/Servlet所在的WEB应用的配置信息。<br>
8、page 来源于当前被访问JSP页面的实例化。它实际使用的是JSP转换成的Servlet。<br>
9、exception 用于捕获JSP抛出的异常。它只有在JSP页面属性isErrorPage=true时才可用。</p>
<h2 id="jsp九种内置对象">JSP九种内置对象：</h2>
<h4 id="一-request对象">一  request对象：</h4>
<p>该对象封装了用户提交的信息，通过调用该对象相应的方法可以获取封装的信息， 即使用该对象可以获取用户提交信息。 客户端的请求参数都被封装到这个对象里面</p>
<h4 id="二-response对象">二  response对象：</h4>
<p>对客户的请求做出动态的响应，向客户端发送数据。</p>
<h4 id="三-session对象">三  session对象</h4>
<p>1.什么是session：session对象是一个JSP内置对象，它在第一个JSP页面被装载时自动创建，完成会话期管理。<br>
从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。当一个客户访问一个服务器时，可能会在这个服务器的几个页面之间反复连接，反复刷新一个页面，服务器应当通过某种办法知道这是同一个客户，这就需要session对象。<br>
2．session对象的ID：当一个客户首次访问服务器上的一个JSP页面时，JSP引擎产生一个session对象，同时分配一个String类型的ID号，JSP引擎同时将这个ID号发送到客户端，存放在Cookie中，这样session对象和客户之间就建立了一一对应的关系。当客户再访问连接该服务器的其他页面时，不再分配给客户新的session对象，直到客户关闭浏览器后，服务器端该客户的session对象才取消，并且和客户的会话对应关系消失。当客户重新打开浏览器再连接到该服务器时，服务器为该客户再创建一个新的session对象。</p>
<h4 id="四-aplication对象">四  aplication对象</h4>
<p>1．什么是application:<br>
服务器启动后就产生了这个application对象，当客户在所访问的网站的各个页面之间浏览时，这个application对象都是同一个，直到服务器关闭。但是与session不同的是，所有客户的application对象都是同一个，即所有客户共享这个内置的application对象。<br>
2．application对象常用方法:<br>
(1)public void setAttribute(String key,Object obj): 将参数Object指定的对象obj添加到application对象中，并为添加的对象指定一个索引关键字。<br>
(2)public Object getAttribute(String key): 获取application对象中含有关键字的对象。</p>
<h4 id="五-out对象">五 out对象</h4>
<p>out 对象是一个输出流，用来向客户端输出数据。out对象用于各种数据的输出。</p>
<h4 id="六-page-javalangobject">六  page java.lang.Object</h4>
<p>对应this关键字。JSP网页本身<br>
page对象是当前页面转换后的Servlet类的实例。从转换后的Servlet类的代码中，可以看到这种关系：<br>
Object page = this;<br>
在JSP页面中，很少使用page对象。</p>
<h4 id="七-config">七  config</h4>
<p>javax.servlet. ServletConfig 的实例，该实例代表该JSP 的配置信息。常用的方法有getInitPararneter(String paramNarne) 及getInitPararneternarnes() 等方法。事实上， JSP 页面通常无须配置，也就不存在配置信息。因此，该对象更多地在Servlet 中有效。</p>
<h4 id="八-exception-javalangthrowable-的实例">八  exception java.lang.Throwable 的实例</h4>
<p>该实例代表其他页面中的异常和错误。只有当页面是错误处理页面，即编译指令page 的isErrorPage 属性为true 时，该对象才可以使用。常用的方法有getMessageO和printStackTraceO等。</p>
<h4 id="九-pagecontext">九  pageContext</h4>
<p>javax.servlet.jsp.PageContext 的实例，对象直译时可以称作“页面上下文”对象，代表的是当前页面运行的一些属性，通过此对象可以拿到其他8大对象，使用该对象可以访问页面中的共享数据。常用的方法有getServletContextO和getServletConfigO等。</p>
<h2 id="四个作用域request域-session域-application域-page域">四个作用域：request域  session域  application域  page域</h2>
<h4 id="application">application：</h4>
<p>全局作用范围，整个应用程序共享，就是在部署文件中的同一个webApp共享，生命周期为：应用程序启动到停止。</p>
<h4 id="session">session：</h4>
<p>会话作用域，当用户首次访问时，产生一个新的会话，以后服务器就可以记住这个会话状态。生命周期：会话超时，或者服务器端强制使会话失效。</p>
<h4 id="request">request：</h4>
<p>请求作用域，就是客户端的一次请求。</p>
<h4 id="page">page：</h4>
<p>一个JSP页面。</p>
<p>以上作用范围使越来越小， request和page的生命周期都是短暂的，他们之间的区别就是：一个request可以包含多个page页(include，forward以及filter)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot与Spring MVC的区别[转]]]></title>
        <id>https://guanxuchao.com//post/spring-boot-yu-spring-mvc-de-qu-bie</id>
        <link href="https://guanxuchao.com//post/spring-boot-yu-spring-mvc-de-qu-bie">
        </link>
        <updated>2019-08-11T08:56:30.000Z</updated>
        <summary type="html"><![CDATA[<p>Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。</p>
<!-- more -->
<p>但他们的基础都是Spring 的 ioc和 aop ioc 提供了依赖注入的容器 aop ，解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。Spring MVC是基于 Servlet 的一个 MVC 框架 主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种XML、 JavaConfig、hin处理起来比较繁琐。于是为了简化开发者的使用，从而创造性地推出了Spring boot，约定优于配置，简化了spring的配置流程。</p>
<p>说得更简便一些：Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。</p>
<h3 id="spring-mvc的功能">Spring MVC的功能</h3>
<pre><code>Spring MVC提供了一种轻度耦合的方式来开发web应用。
</code></pre>
<p>Spring MVC是Spring的一个模块，式一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。</p>
<h3 id="spring-boot的功能">Spring Boot的功能</h3>
<pre><code>Spring Boot实现了自动配置，降低了项目搭建的复杂度。
</code></pre>
<p>众所周知Spring框架需要进行大量的配置，Spring Boot引入自动配置的概念，让项目设置变得很容易。Spring Boot本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，Spring Boot应用中这些第三方库几乎可以零配置的开箱即用(out-of-the-box)，大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p>
<p>Spring Boot只是承载者，辅助你简化项目搭建过程的。如果承载的是WEB项目，使用Spring MVC作为MVC框架，那么工作流程和你上面描述的是完全一样的，因为这部分工作是Spring MVC做的而不是Spring Boot。</p>
<p>对使用者来说，换用Spring Boot以后，项目初始化方法变了，配置文件变了，另外就是不需要单独安装Tomcat这类容器服务器了，maven打出jar包直接跑起来就是个网站，但你最核心的业务逻辑实现与业务流程实现没有任何变化。</p>
<pre><code>所以，用最简练的语言概括就是： 	

Spring 是一个“引擎”； 

Spring MVC 是基于Spring的一个 MVC 框架 ；

Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。
</code></pre>
<p><br>链接：https://www.zhihu.com/question/64671972/answer/223383505</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表]]></title>
        <id>https://guanxuchao.com//post/lian-biao</id>
        <link href="https://guanxuchao.com//post/lian-biao">
        </link>
        <updated>2019-08-10T07:47:25.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="1什么是链表">1.什么是链表?</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="1什么是链表">1.什么是链表?</h1>
<!-- more -->
<pre><code>链表由一系列节点构成，其中，每个节点
包含两部分内容(一部分是数据，另外一部分是
指针）。
注:
	指针指向了下一个节点(也就是说通过该指针
可以找到下一个节点)。
	如果只有一个指向下一个节点的指针，称之为
单向链表。
	如果有两个指针(一个指向上一个节点，一个指)
向下一个节点)，称之为两向链表。
	如果最后一个节点与第一个节点也通过指针
连接起来，称之为双向循环链表。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://guanxuchao.com//post-images/1565882087342.png" alt=""></figure>
<h1 id="2链表跟数组相比优缺点是什么">2.链表跟数组相比，优缺点是什么?</h1>
<pre><code>数组的优点:
	依据下标可以非常快速的找到某个元素。
数组的缺点:
	删除和插入操作比较耗费时间，需要重新
移动大量元素(包括扩容)。
	数组需要有连续的地址空间。

链表的优点:
	删除和插入操作速度非常快。
	链表不需要连续的地址空间。
链表的缺点:
	依据下标查找某个元素比较慢。			
	链表节点需要保存节点的地址，同数组相比，
	需要占用更多的内存。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot]]></title>
        <id>https://guanxuchao.com//post/springboot</id>
        <link href="https://guanxuchao.com//post/springboot">
        </link>
        <updated>2019-08-03T07:46:18.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="1-springboot的作用">1. SpringBoot的作用</h3>
<p>SpringBoot是默认整合了Spring、SpringMVC及相关常用框架的一个综合性框架，大量的减少了相关的配置，使得创建项目和使用变得更加简单。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="1-springboot的作用">1. SpringBoot的作用</h3>
<p>SpringBoot是默认整合了Spring、SpringMVC及相关常用框架的一个综合性框架，大量的减少了相关的配置，使得创建项目和使用变得更加简单。</p>
<!-- more -->
<p>在常规配置方面，SpringBoot的思想是“约定大于配置”，即：大多数开发者都会使用某种配置方式的话，则SpringBoot就会直接配置成那个样子，然后，开发者在使用SpringBoot时就不用再进行相关配置，只需要知道已经被配置为那个样子了就可以了！</p>
<h3 id="2-创建springboot项目">2. 创建SpringBoot项目</h3>
<p>需要打开浏览器，访问<code>https://start.spring.io/</code>，填写创建项目的参数，配置完成后，点击<strong>Generate the project</strong>即可生成项目。</p>
<p>解压缩下载得到的压缩包，其中的文件夹就是项目文件夹，推荐将该文件夹移动到Workspace中，然后通过Eclipse的<strong>Import</strong> -&gt; <strong>Exsiting Maven Projects</strong>导入该项目，务必保证当前可以连接到Maven服务器，导入后，会自动下载大量依赖，直至项目结构完整。</p>
<h3 id="3-springboot-helloworld">3. SpringBoot HelloWorld</h3>
<p>在<strong>src/main/resources</strong>下默认已经存在<strong>static</strong>的文件夹，该文件是SpringBoot项目用于存放静态资源的文件夹，例如存放<code>.html</code>文件、图片、<code>.css</code>文件、<code>.js</code>文件等，相当于传统项目中的<strong>webapp</strong>文件夹，则可以在<strong>static</strong>创建<strong>index.html</strong>欢迎页面。</p>
<p>在<strong>src/main/java</strong>下默认已经存在<code>cn.tedu.springboot.sample</code>包，该包名是根据创建项目时的参数决定的，这个包就是当前项目的根包(Base-Package)，并且在该包下已经存在<code>SampleApplication.java</code>文件，该文件的名称也是根据创建项目时填写的<strong>artifact</strong>决定的，该文件中包含<code>main()</code>方法，直接执行<code>main()</code>方法就可以启动当前项目，所以，该类也是SpringBoot的启动类！</p>
<p>SpringBoot项目在启动时会启动内置的Tomcat，默认占用8080端口，如果此前该端口已经处于占用状态，则项目会启动失败！</p>
<p>通过<code>http://localhost:8080</code>即可访问所涉及的网页，由于SpringBoot项目内置Tomcat，该Tomcat只为当前项目服务，所以启动时设置的Context Path是空字符串，在访问时URL中不必添加项目名称，而<strong>index.html</strong>是默认的欢迎页面，其文件名也不必体现在URL中！</p>
<h3 id="4-springboot-mybatis环境">4. SpringBoot + MyBatis环境</h3>
<p>SpringBoot项目默认没有集成持久层相关依赖，需要手动补充，或者创建项目时就选中：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
	&lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
	&lt;groupId&gt;mysql&lt;/groupId&gt;
	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
	&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>当添加以上依赖之后，SpringBoot项目再启动时就会尝试读取连接数据库的相关配置，如果还没有配置，则会启动失败！</p>
<p>在<strong>src/main/resources</strong>下有<strong>application.properties</strong>，该文件就是SpringBoot的配置文件，在该文件中添加配置：</p>
<pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/tedu_ums?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
<blockquote>
<p>一般情况下，不需要配置连接数据库的driverClassName，因为SpringBoot会自动从jar中读取！</p>
</blockquote>
<p>添加以上配置后，项目可以正常启动，但是，如果以上配置信息是错误的，也不影响启动过程，也就是说，SpringBoot启动时，会读取相关配置，但是，并不执行数据库连接，所以，就算是配置错误也并不会体现出来。</p>
<h3 id="5-测试数据库连接">5. 测试数据库连接</h3>
<p>在<strong>src/test/java</strong>下，默认已经存在项目的根包及测试类，且测试类中已经存在一个空的测试方法：</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class SampleApplicationTests {

	@Test
	public void contextLoads() {
	}

}
</code></pre>
<p>可以先执行以上<code>contextLoads()</code>方法的单元测试，如果测试出错，一定是测试环境或者框架环境有问题，多考虑为jar包已经损坏，应该重新下载或者更换版本！</p>
<p>可以在该测试类中编写单元测试：</p>
<pre><code>@Autowired
private DataSource dataSource;

@Test
public void getConnection() throws SQLException {
	Connection conn = dataSource.getConnection();
	System.err.println(conn);
}
</code></pre>
<p>如果测试通过，则此前配置的数据库连接信息是正确的！</p>
<h3 id="6-注册功能的持久层接口">6. 注册功能的持久层接口</h3>
<p>先创建与数据表对应的实体类<code>cn.tedu.springboot.sample.entity.User</code>：</p>
<pre><code>public class User implements Serializable {

	private static final long serialVersionUID = 7019981109167736281L;

	private Integer id;
	private String username;
	private String password;
	private Integer age;
	private String phone;
	private String email;
	private Integer isDelete;
	private Integer departmentId;

	// ...
}
</code></pre>
<p>然后，创建持久层接口<code>cn.tedu.springboot.sample.mapper.UserMapper</code>：</p>
<pre><code>public interface UserMapper {
	
	Integer insert(User user);
	
	User findByUsername(String username);

}
</code></pre>
<p>为了保证MyBatis框架能确定接口文件的位置，可以在接口的声明之前添加<code>@Mapper</code>注解，不过，这样的做法就要求每一个持久层接口之前都需要添加该注解，也可以在启动类<code>SampleApplication</code>之前添加<code>@MapperScan</code>注解进行配置，则后续只需要把持久层接口都放在这个包中就可以了，无需反复添加注解：</p>
<pre><code>@SpringBootApplication
@MapperScan(&quot;cn.tedu.springboot.sample.mapper&quot;)
public class SampleApplication {

	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}

}
</code></pre>
<h3 id="7-注册功能的映射">7. 注册功能的映射</h3>
<p>可以在每一个抽象方法之前使用注解配置所对应的SQL语句，例如：</p>
<pre><code>@Options(useGeneratedKeys=true, keyProperty=&quot;id&quot;)
@Insert(&quot;insert into t_user (字段列表) values (值列表)&quot;)
Integer insert(User user);
</code></pre>
<p>这种做法是MyBatis本身就支持的，并不是SpringBoot所特有的！这种做法最大的优点在于：对应关系非常直观。主要的缺陷在于：配置长篇的SQL语句时，代码不易于阅读和维护！所以，一般仍然推荐使用XML配置映射的SQL语句！</p>
<p>与此前一样，在<strong>src/main/resources</strong>下创建名为<strong>mappers</strong>的文件夹，然后使用<strong>UserMapper.xml</strong>进行配置：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  
&lt;!DOCTYPE mapper PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot;      
	&quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&gt;

&lt;!-- namespace：当前XML文件用于配置哪个接口中抽象方法对应的SQL语句 --&gt;
&lt;mapper namespace=&quot;cn.tedu.springboot.sample.mapper.UserMapper&quot;&gt;

	&lt;!-- resultMap节点：指导MyBatis如何封装查询结果 --&gt;
	&lt;!-- id：自定义名称 --&gt;
	&lt;!-- column：查询结果中的列名 --&gt;
	&lt;!-- property：type对应的类中的属性名 --&gt;
	&lt;resultMap id=&quot;UserEntityMap&quot;
		 type=&quot;cn.tedu.springboot.sample.entity.User&quot;&gt;
		&lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
		&lt;result column=&quot;username&quot; property=&quot;username&quot; /&gt;
		&lt;result column=&quot;password&quot; property=&quot;password&quot; /&gt;
		&lt;result column=&quot;age&quot; property=&quot;age&quot; /&gt;
		&lt;result column=&quot;phone&quot; property=&quot;phone&quot; /&gt;
		&lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;
		&lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot; /&gt;
		&lt;result column=&quot;department_id&quot; property=&quot;departmentId&quot; /&gt;
	&lt;/resultMap&gt;

	&lt;!-- 使用insert节点配置插入数据的SQL语句 --&gt;
	&lt;!-- id：抽象方法的方法名 --&gt;
	&lt;!-- 在#{}中间的是方法的参数User类中的属性名称 --&gt;
	&lt;insert id=&quot;insert&quot;
		useGeneratedKeys=&quot;true&quot;
		keyProperty=&quot;id&quot;&gt;
		INSERT INTO t_user (
			username, password,
			age, phone,
			email, is_delete,
			department_id
		) VALUES (
			#{username}, #{password},
			#{age}, #{phone},
			#{email}, #{isDelete},
			#{departmentId}
		)
	&lt;/insert&gt;
	
	&lt;select id=&quot;findByUsername&quot;
		resultMap=&quot;UserEntityMap&quot;&gt;
		SELECT 
			* 
		FROM 
			t_user 
		WHERE 
			username=#{username} 
	&lt;/select&gt;
	
&lt;/mapper&gt;
</code></pre>
<p>另外，还需要配置XML文件的位置，则打开<strong>application.properties</strong>文件添加配置：</p>
<pre><code>mybatis.mapper-locations=classpath:mappers/*.xml
</code></pre>
<h3 id="8-持久层单元测试">8. 持久层单元测试</h3>
<p>在<strong>src/test/java</strong>下创建<code>cn.tedu.springboot.sample.mapper.UserMapperTests</code>单元测试类，将默认存在的<code>SampleApplicationTests</code>类之前的2行注解复制到<code>UserMapperTests</code>类之前：</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTests {
}
</code></pre>
<p>然后，在类中声明持久层对象的属性：</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTests {
	
	@Autowired
	private UserMapper mapper;

}
</code></pre>
<blockquote>
<p>凡是以前在SSM项目中可以通过<code>getBean()</code>方式获取的对象，在SpringBoot项目中都可以自动装配！</p>
</blockquote>
<p>然后，编写并执行测试方法：</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTests {
	
	@Autowired
	private UserMapper mapper;

	@Test
	public void insert() {
		User user = new User();
		user.setUsername(&quot;springboot&quot;);
		user.setPassword(&quot;1234&quot;);
		Integer rows = mapper.insert(user);
		System.err.println(&quot;rows=&quot; + rows);
	}
	
	@Test
	public void findByUsername() {
		String username = &quot;springboot&quot;;
		User user = mapper.findByUsername(username);
		System.err.println(user);
	}
}
</code></pre>
<h3 id="9-编写控制器处理请求">9. 编写控制器处理请求</h3>
<p>先创建控制器处理请求后的返回结果对象的类型<code>cn.tedu.springboot.sample.util.JsonResult</code>：</p>
<pre><code>public class JsonResult {
	private Integer state;
	private String message;

	// SET/GET ...
}
</code></pre>
<p>SpringBoot项目不需要开发者配置组件扫描，它默认的组件扫描就是项目的根包，即<code>cn.tedu.springboot.sample</code>包，当前项目中所有的组件都必须在这个包或者其子包下！</p>
<p>所以，创建<code>cn.tedu.springboot.sample.controller.UserController</code>控制器类，在类之前添加<code>@RestController</code>注解和<code>@RequestMapping(&quot;user&quot;)</code>注解：</p>
<pre><code>@RestController
@RequestMapping(&quot;user&quot;)
public class UserController {

}
</code></pre>
<blockquote>
<p>使用<code>@RestController</code>相当于<code>@Controller</code>和<code>@ResponseBody</code>的组合使用方式，当使用了<code>@RestController</code>时，该控制器类中所有处理请求的方法都是相当于添加了<code>@ResponseBody</code>注解的！一旦使用了该注解，该控制器类中的方法将不可以转发或者重定向，如果一定要转发或者重定向，必须使用<code>ModelAndView</code>作为处理请求的方法的返回值！</p>
</blockquote>
<p>然后，在控制器类中添加处理请求的方法：</p>
<pre><code>// /user/reg
@RequestMapping(&quot;reg&quot;)
public JsonResult reg(User user) {
}
</code></pre>
<blockquote>
<p>在SpringBoot项目中，默认已经将<code>DispatcherServlet</code>映射的路径配置为<code>/*</code>，即所有请求。</p>
</blockquote>
<p>在处理过程中，显然需要使用到持久层对象来完成数据操作，所以，应该声明持久层对象的属性：</p>
<pre><code>@Autowired
private UserMapper userMapper;
</code></pre>
<p>然后，完成处理请求的细节：</p>
<pre><code>@RequestMapping(&quot;reg&quot;)
public JsonResult reg(User user) {
	// 创建返回值对象
	// 从参数user中获取尝试注册的用户名
	// 根据以上用户名查询用户数据
	// 检查查询结果是否为null
	// 是：用户名未被占用
	// -- 执行注册
	// -- 封装返回值对象的属性：1
	// 否：用户名已经被占用
	// -- 封装返回值对象的属性：2, 错误提示信息
	// 返回
}
</code></pre>
<p>具体实现代码：</p>
<pre><code>@RequestMapping(&quot;reg&quot;)
public JsonResult reg(User user) {
	// 创建返回值对象
	JsonResult jsonResult = new JsonResult();
	// 从参数user中获取尝试注册的用户名
	String username = user.getUsername();
	// 根据以上用户名查询用户数据
	User result = userMapper.findByUsername(username);
	// 检查查询结果是否为null
	if (result == null) {
		// 是：用户名未被占用
		// 执行注册
		userMapper.insert(user);
		// 封装返回值对象的属性：1
		jsonResult.setState(1);
	} else {
		// 否：用户名已经被占用
		// 封装返回值对象的属性：2, 错误提示信息
		jsonResult.setState(2);
		jsonResult.setMessage(&quot;注册失败！尝试注册的用户名(&quot; + username + &quot;)已经被占用！&quot;);
	}
	// 返回
	return jsonResult;
}
</code></pre>
<p>完成后，通过启动类启动项目，打开浏览器，输入<code>http://localhost:8080/user/reg?username=junit&amp;password=1234</code>进行测试。</p>
<p>在对方法添加注解配置映射的路径时，除了<code>@RequestMapping</code>以外，还可以使用<code>@GetMapping</code>、<code>@PostMapping</code>等，它们都是限制了请求方式的！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AJAX]]></title>
        <id>https://guanxuchao.com//post/ajax</id>
        <link href="https://guanxuchao.com//post/ajax">
        </link>
        <updated>2019-07-28T07:45:04.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="1-服务器端如何响应请求">1. 服务器端如何响应请求</h3>
<p>服务器端只响应客户端所需要的数据</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="1-服务器端如何响应请求">1. 服务器端如何响应请求</h3>
<p>服务器端只响应客户端所需要的数据</p>
<!-- more -->
<p>传统的响应方式有转发和重定向，这样的做法有很多问题，比如：转发和重定向都决定了响应的具体页面，不适合多种客户端（浏览器、Android手机、Android平板电脑、iOS手机、iOS平板电脑……）的项目，因为不同的终端设备的性能特征是不一样的，把同样的一个页面都显示给不同的终端设备是极不合适的！正确的做法应该是“服务器端只响应客户端所需要的数据”，至于这些数据如何呈现在终端设备中，由各客户端的开发团队去解决！</p>
<p>如果使用响应正文的方式，还存在“响应数据量小”的优势，则响应速度更快，产生的流量消耗小，用户体验好！</p>
<h3 id="2-服务器端响应正文">2. 服务器端响应正文</h3>
<p>假设客户端会提交<code>http://localhost:8080/AJAX/user/login.do</code>请求，如果需要响应方式是“响应正文”，则需要在处理请求的方法之前补充添加<code>@ResponseBody</code>注解：</p>
<pre><code>@Controller
@RequestMapping(&quot;user&quot;)
public class UserController {
	
	@RequestMapping(&quot;login.do&quot;)
	@ResponseBody
	public String login() {
		return &quot;LOGIN SUCCESS.&quot;;
	}

}
</code></pre>
<p>默认情况下，响应的内容使用了ISO-8859-1编码，所以，不支持中文。</p>
<p>练习：用户在此次提交请求时，<strong>必须</strong>提交用户名和密码作为请求参数，仅当用户名为<code>root</code>且密码为<code>1234</code>时会登录成功(<code>LOGIN SUCCESS.</code>)，否则，响应用户名错误(<code>USERNAME ERROR.</code>)或者密码错误(<code>PASSWORD ERROR.</code>)。</p>
<h3 id="3-服务器响应的正文格式-json格式">3. 服务器响应的正文格式--JSON格式</h3>
<p>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p>
<p>通常，服务器向客户端响应的数据可能不只是1个数据，以登录操作为例，也许可以响应为<code>1</code>表示登录成功，使用<code>2</code>表示登录失败且是因为用户名错误，使用<code>3</code>表示密码错误，则客户端就可以通过对这个值的判断，得知当前操作结果，但是，其它操作可能会需要更多的数据，例如“客户端尝试获取当前登录的用户信息”，需要响应的数据可能包括：用户名、手机号码、电子邮箱、年龄等一系列数据，由于响应结果只是1个字符串，要把这些数据很好的组织起来，才可以方便客户端从这1个字符串中获取其中某部分的数据，否则，如果只是响应为<code>&quot;root13800138001root@163.com26&quot;</code>这样，客户端就无法处理这个响应结果。</p>
<p>早期通常使用XML语法来组织这些数据：</p>
<pre><code>&lt;user&gt;
	&lt;username&gt;root&lt;/username&gt;
	&lt;age&gt;26&lt;/age&gt;
	&lt;phone&gt;13800138001&lt;/phone&gt;
	&lt;email&gt;root@163.com&lt;/email&gt;
&lt;/user&gt;
</code></pre>
<p>使用XML存在的问题：</p>
<ul>
<li>
<p>数据量略大，传输略慢，流量消耗略大，用户体验略差；</p>
</li>
<li>
<p>解析难度大。</p>
</li>
</ul>
<p>目前推荐使用的组织数据的格式是JSON格式，以上数据使用JSON组织后的表现为：</p>
<pre><code>{
	&quot;username&quot;:&quot;root&quot;,
	&quot;age&quot;:26,
	&quot;phone&quot;:&quot;13800138001&quot;,
	&quot;email&quot;:&quot;root@163.com&quot;,
	&quot;skill&quot;:[&quot;Java&quot;, &quot;Java OOP&quot;, &quot;Java SE&quot;, &quot;Java WEB&quot;, &quot;MySQL&quot;, &quot;Spring&quot;],
	&quot;department&quot;:{
		&quot;id&quot;:1,
		&quot;name&quot;:&quot;RD&quot;
	}
}
</code></pre>
<p>JSON数据在Javascript中是默认即识别的对象，可以直接得到其中的属性值：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
	var json = {
		&quot;username&quot;:&quot;root&quot;,
		&quot;age&quot;:26,
		&quot;phone&quot;:&quot;13800138001&quot;,
		&quot;email&quot;:&quot;root@163.com&quot;
	};

	console.log(json.username);
	console.log(json.age);
&lt;/script&gt;
</code></pre>
<p>关于JSON数据格式：</p>
<ul>
<li>
<p>使用<code>{}</code>表示对象，整个JSON数据就是1个对象；</p>
</li>
<li>
<p>所有的属性名都是字符串类型的，在JavaScript中，可以使用单引号或者双引号框柱，因为JSON数据可能在多种不同的编程语言中都出现，一般推荐使用双引号，属性值如果是字符串，也需要使用双引号框柱，如果是数值或者布尔值，则可以不用双引号框柱，属性名和属性值使用冒号<code>:</code>分隔，多个属性的配置之间使用逗号<code>,</code>分隔；</p>
</li>
<li>
<p>属性值的类型还可以是数组，使用中括号<code>[]</code>框柱数组的各元素，各元素之间使用逗号<code>,</code>分隔，在JavaScript中处理时，使用例如<code>json.skill</code>就可以获取到整个数组，使用<code>json.skill.length</code>就可以获取数组的长度，使用<code>json.skill[0]</code>就可以获取数组中下标为0的元素，也可以使用循环语法进行循环；</p>
</li>
<li>
<p>属性值的类型还可以是另一个对象，使用<code>{}</code>表示对象。</p>
</li>
</ul>
<p>如果在JavaScript中，得到是一个使用JSON语法组织的字符串，而不是JSON对象，可以调用<code>JSON.parse(str)</code>函数，将字符串转换为JSON对象。</p>
<h3 id="4-服务器端实现响应json格式的数据">4. 服务器端实现响应JSON格式的数据</h3>
<p>如果需要服务端响应JSON格式的数据，不可能自行拼接出JSON格式的字符串，可以通过工具来解决，首先，需要添加<code>jackson-databind</code>的依赖：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
	&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
	&lt;version&gt;2.9.8&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后，在项目中自定义<code>cn.tedu.ajax.JsonResult</code>响应结果类型：</p>
<pre><code>public class JsonResult {
	
	private Integer state;
	private String message;

	public Integer getState() {
		return state;
	}

	public void setState(Integer state) {
		this.state = state;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

}
</code></pre>
<p>并修改处理请求的方法，返回值类型使用以上自定义的类型：</p>
<pre><code>@RequestMapping(&quot;login.do&quot;)
@ResponseBody
public JsonResult login(
	@RequestParam(&quot;username&quot;) String username,
	@RequestParam(&quot;password&quot;) String password) {
	Integer state;
	String message = null;
	
	if (&quot;root&quot;.equals(username)) {
		if (&quot;1234&quot;.equals(password)) {
			state = 1;
		} else {
			state = 3;
			message = &quot;密码错误！&quot;;
		}
	} else {
		state = 2;
		message = &quot;用户名不存在！&quot;;
	}
	
	JsonResult jsonResult = new JsonResult();
	jsonResult.setState(state);
	jsonResult.setMessage(message);
	return jsonResult;
}
</code></pre>
<p>如果直接运行，会提示406错误：</p>
<pre><code>HTTP Status 406 – Not Acceptable
</code></pre>
<p>需要在spring.xml中添加配置：</p>
<pre><code>&lt;!-- 注解驱动 --&gt;
&lt;mvc:annotation-driven /&gt;
</code></pre>
<p>然后，控制器中处理请求的方法响应的正文就是JSON格式的字符串了。</p>
<p>在控制器中响应正文时，需要添加<code>@ResponseBody</code>注解，SpringMVC框架内置了一系列的转换器(Converter)，用于将方法的返回值转换为响应的正文，在这一系列的转换器中，SpringMVC设计了对应关系和优先级，例如，当方法的返回值类型是<code>String</code>时，就会自动调用<code>StringHttpMessageConverter</code>，当项目中添加了<code>jackson-databind</code>依赖时，如果方法的返回值类型是SpringMVC默认不识别的，就会自动使用<code>Jackson</code>依赖中的转换器！<code>Jackson</code>依赖还会将响应头(Response Headers)中的<code>Content-Type</code>设置为<code>application/json, charset=utf-8</code>。</p>
<p><strong>小结：需要自定义数据类型，以决定响应的JSON数据格式(有哪些属性，分别是什么类型)，然后用自定义类型作为方法的返回值，并处理完成后返回该类型的对象，<code>Jackson</code>依赖就会自动的设置为支持中文，且把响应的对象转换成JSON字符串。</strong></p>
<h3 id="5-ajax">5. AJAX</h3>
<p>AJAX = Asynchronous JavaScript and XML（异步的JavaScript和XML）。</p>
<p>AJAX不是新的编程语言，而是一种使用现有标准的新方法。</p>
<p>AJAX是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>
<p>在实际实现时，通常是基于jQuery框架实现AJAX访问，主要是因为原生技术的代码比较繁琐，且存在浏览器的兼容性问题，在jQuery中，定义了<code>$.ajax()</code>函数，用于处理AJAX请求，调用该函数即可实现异步访问：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(&quot;#btn-login&quot;).click(function(){
	// $.ajax()函数的参数是1个JSON对象
	// url：请求提交到哪里
	// data：需要提交的请求参数
	// type：请求类型
	// dataType：服务器端响应的数据类型，可以是text/xml/json，取值取决于Response Headers中的Content-Type
	// success：服务器端HTTP响应码是2xx时的回调(callback)函数，函数的参数就是服务器端响应的正文结果
	$.ajax({
		&quot;url&quot;:&quot;user/login.do&quot;,
		&quot;data&quot;:$(&quot;#form-login&quot;).serialize(),
		&quot;type&quot;:&quot;post&quot;,
		&quot;dataType&quot;:&quot;json&quot;,
		&quot;success&quot;:function(result) {
			if (result.state == 1) {
				alert(&quot;登录成功！&quot;);
			} else {
				alert(result.message);
			}
		}
	});
});
&lt;/script&gt;</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis-2]]></title>
        <id>https://guanxuchao.com//post/mybatis-2</id>
        <link href="https://guanxuchao.com//post/mybatis-2">
        </link>
        <updated>2019-07-27T07:44:31.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="1-使用mybatis实现简单的查询">1. 使用MyBatis实现简单的查询</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="1-使用mybatis实现简单的查询">1. 使用MyBatis实现简单的查询</h3>
<!-- more -->
<p>在设计查询的抽象方法时：</p>
<ol>
<li>
<p>返回值类型使用所期望的类型；</p>
</li>
<li>
<p>其它部分的设计与增/删/改相同；</p>
</li>
<li>
<p>如果查询的是某1条数据记录，如果有匹配的数据，则返回正确的查询结果，如果没有匹配的数据，将返回<code>null</code>。</p>
</li>
</ol>
<p>例如：根据用户id查询用户数据详情时：</p>
<pre><code>User findById(Integer id);
</code></pre>
<p>在配置该方法的XML映射时，使用的<code>&lt;select&gt;</code>节点必须配置<code>resultType</code>或者<code>resultMap</code>属性中的某一个：</p>
<pre><code>&lt;select id=&quot;findById&quot;
	resultType=&quot;cn.tedu.mybatis.User&quot;&gt;
	SELECT * FROM t_user WHERE id=#{id}
&lt;/select&gt;
</code></pre>
<p>例如：获取当前数据表用户数据的数量：</p>
<pre><code>Integer count();
</code></pre>
<p>映射配置为：</p>
<pre><code>&lt;select id=&quot;count&quot;
	resultType=&quot;java.lang.Integer&quot;&gt;
	SELECT COUNT(*) FROM t_user
&lt;/select&gt;
</code></pre>
<p>例如：查询所有用户数据时：</p>
<pre><code>List&lt;User&gt; findAll();
</code></pre>
<p>配置的映射：</p>
<pre><code>&lt;select id=&quot;findAll&quot;
	resultType=&quot;cn.tedu.mybatis.User&quot;&gt;
	SELECT * FROM t_user ORDER BY id ASC
&lt;/select&gt;
</code></pre>
<h3 id="2-使用多个参数">2. 使用多个参数</h3>
<p>假设需要实现：将id=?的用户的密码修改为?，则抽象方法：</p>
<pre><code>Integer updatePasswordById(Integer id, String newPassword);
</code></pre>
<p>然后配置xml中的映射：</p>
<pre><code>&lt;update id=&quot;updatePasswordById&quot;&gt;
	UPDATE t_user SET password=#{newPassword} where id=#{id}
&lt;/update&gt;
</code></pre>
<p>如果直接执行以上代码，会报告错误：</p>
<pre><code>org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter 'newPassword' not found. Available parameters are [arg1, arg0, param1, param2]
</code></pre>
<p>根本原因是MyBatis框架只能识别1个参数，无论这个参数是什么，都会直接被使用，而多余的参数是不可识别的！</p>
<p>可以在抽象方法的每一个参数之前添加<code>@Param</code>注解，MyBatis框架在处理时，会将这些参数封装成1个Map，依然能满足“只能识别1个参数”的需求，后续在配置XML映射时，使用的<code>#{}</code>占位符中的名称就必须是注解中配置的名称，表示的是MyBatis自动封装的Map中的Key：</p>
<pre><code>Integer updatePasswordById(
		@Param(&quot;id&quot;) Integer arg0, 
		@Param(&quot;password&quot;) String arg1);
</code></pre>
<p>配置的XML映射：</p>
<pre><code>&lt;update id=&quot;updatePasswordById&quot;&gt;
	UPDATE t_user SET password=#{password} where id=#{id}
&lt;/update&gt;
</code></pre>
<p><strong>小结：如果涉及的抽象方法的参数达到2个甚至更多，则每个参数之前都必须添加<code>@Param</code>注解，并在注解中指定名称，后续配置XML映射时，使用的<code>#{}</code>中的名称也是注解中配置的名称！</strong></p>
<p>练习：同时根据用户名和密码查询用户数据！</p>
<h3 id="3-动态sql-foreach">3. 动态SQL-foreach</h3>
<p>MyBatis中的动态SQL指的是根据参数不同，动态的生成不同的SQL语句。</p>
<p>例如：根据若干个id删除用户数据，设计的抽象方法：</p>
<pre><code>Integer deleteByIds(List&lt;Integer&gt; ids);
</code></pre>
<p>然后，在配置映射时：</p>
<pre><code>&lt;delete id=&quot;deleteByIds&quot;&gt;
	DELETE FROM 
		t_user 
	WHERE 
		id 
	IN 
		(
		&lt;foreach collection=&quot;list&quot;
			item=&quot;id&quot; separator=&quot;,&quot;&gt;
			#{id}
		&lt;/foreach&gt;
		)
&lt;/delete&gt;
</code></pre>
<p>在配置<code>&lt;foreach&gt;</code>节点时：</p>
<ul>
<li>
<p><code>collection</code>：被遍历的参数对象，首先，如果对应的抽象方法的参数只有1个时，如果参数是<code>List</code>集合类型的，取值为<code>list</code>，如果参数是数组类型的，取值为<code>array</code>，另外，如果对应的抽象方法的参数有多个，则每个参数肯定都添加了<code>@Param</code>注解，此处需要配置的值就是注解中配置的名称；</p>
</li>
<li>
<p><code>item</code>：遍历过程中获取到的数据的名称，相当于增强for循环的语法中，括号中的第2个部分，在<code>&lt;foreach&gt;</code>节点的子级可以使用<code>#{}</code>占位符，占位符中的名称就是<code>item</code>属性的值；</p>
</li>
<li>
<p><code>separator</code>：遍历过程中各元素使用的分隔符；</p>
</li>
<li>
<p><code>open</code>和<code>close</code>：遍历产生的代码的最左侧字符和最右侧字符。</p>
</li>
</ul>
<h3 id="4-动态sql-if">4. 动态SQL-if</h3>
<p>假设存在抽象方法：</p>
<pre><code>List&lt;User&gt; find(String where, String orderBy, Integer offset, Integer count);
</code></pre>
<p>在配置SQL语句时，可以使用if标签进行对参数的判断，从而产生不同的SQL语句的某个部分，例如：</p>
<pre><code>&lt;select id=&quot;xx&quot; resultType=&quot;xx.xx.xx.User&quot;&gt;
	SELECT
		*
	FROM
		t_user
	&lt;if test=&quot;where != null&quot;&gt;
	WHERE
		#{where}
	&lt;/if&gt;
	&lt;if test=&quot;orderBy != null&quot;&gt;
	ORDER BY
		#{orderBy}
	&lt;/if&gt;
	&lt;if test=&quot;offset != null&quot;&gt;
	LIMIT
		#{offset}, #{count}
	&lt;/if&gt;
&lt;/select&gt;
</code></pre>
<p>以上配置是错误的，并不能所有位置都使用<code>#{}</code>占位符，有几处需要使用<code>${}</code>格式的占位符：</p>
<pre><code>&lt;select id=&quot;find&quot; 
	resultType=&quot;cn.tedu.mybatis.User&quot;&gt;
	SELECT
		*
	FROM
		t_user
	&lt;if test=&quot;where != null&quot;&gt;
	WHERE
		${where}
	&lt;/if&gt;
	&lt;if test=&quot;orderBy != null&quot;&gt;
	ORDER BY
		${orderBy}
	&lt;/if&gt;
	&lt;if test=&quot;offset != null&quot;&gt;
	LIMIT
		#{offset}, #{count}
	&lt;/if&gt;
&lt;/select&gt;
</code></pre>
<h3 id="5-mybatis中的占位符">5. MyBatis中的占位符</h3>
<p>在MyBatis中，编写XML中的SQL语句时，可以使用<code>#{}</code>格式的占位符，还可以使用<code>${}</code>格式的占位符！</p>
<p>MyBatis在处理有占位符的SQL时，如果是<code>${}</code>格式的占位符，会先通过字符串拼接的方式把变量值替换并拼接出SQL语句，然后尝试编译该SQL语句，如果是<code>#{}</code>格式的占位符，会使用<code>?</code>进行占位并尝试编译，编译过后再使用值进行替换。</p>
<p>小结：以前在使用JDBC时，可以使用<code>?</code>表示的部分，都应该使用<code>#{}</code>，也可以理解为只有“值”才可以使用<code>#{}</code>，这种做法是预编译的，否则，如果要对SQL语句中的某个子句或者其他语句的某个部分，甚至是WHERE子句中的表达式，使用<code>${}</code>，这种做法并不会预编译。</p>
<h3 id="6-当字段名与属性名不完全相同时的查询">6. 当字段名与属性名不完全相同时的查询</h3>
<p>修改<code>t_user</code>表结构，添加名为<code>is_delete</code>的字段：</p>
<pre><code>alter table t_user add column is_delete int;

update t_user set is_delete=0;
</code></pre>
<p>然后，对应的<code>User</code>类中也需要添加对应的属性，在Java中，不推荐在变量名中使用<code>_</code>符号，所以，添加的属性应该是：</p>
<pre><code>private Integer isDelete;
</code></pre>
<p>由于名称不是完全相同了，所以，此前的查询功能就无法查询出数据的<code>is_delete</code>字段的值！</p>
<p>MyBatis封装查询结果的标准就是“将查询到的数据封装到与列名完全相同的属性中”，所以，如果字段名与属性名不一致，就会导致默认的列名与属性名不一致，可以在查询时，为列名自定义别名，以保持名称一致，所以，解决方案可以是：</p>
<pre><code>SELECT 
	id, username,
	password, age,
	phone, email,
	is_delete AS isDelete
FROM 
	t_user 
ORDER BY 
	id ASC
</code></pre>
<p>如果在查询时，使用<code>*</code>表示要查询的字段列表，MyBatis就无法自动封装那些名称不一致的数据，可以在XML文件配置<code>&lt;resultMap&gt;</code>节点，并且在查询的<code>&lt;select&gt;</code>节点中，使用<code>resultMap</code>属性取代<code>resultType</code>属性：</p>
<pre><code>&lt;!-- resultMap节点：指导MyBatis如何封装查询结果 --&gt;
&lt;!-- id：自定义名称 --&gt;
&lt;!-- column：查询结果中的列名 --&gt;
&lt;!-- property：type对应的类中的属性名 --&gt;
&lt;resultMap id=&quot;UserEntityMap&quot;
	 type=&quot;cn.tedu.mybatis.User&quot;&gt;
	&lt;result column=&quot;id&quot; property=&quot;id&quot; /&gt;
	&lt;result column=&quot;username&quot; property=&quot;username&quot; /&gt;
	&lt;result column=&quot;password&quot; property=&quot;password&quot; /&gt;
	&lt;result column=&quot;age&quot; property=&quot;age&quot; /&gt;
	&lt;result column=&quot;phone&quot; property=&quot;phone&quot; /&gt;
	&lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;
	&lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot; /&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;findAll&quot;
	resultMap=&quot;UserEntityMap&quot;&gt;
	SELECT 
		*
	FROM 
		t_user 
	ORDER BY 
		id ASC
&lt;/select&gt;
</code></pre>
<p><strong>小结：无论是取别名，还是配置<code>&lt;resultMap&gt;</code>，只要能保证MyBatis知道如何封装名称不一致的数据，就可以正确查询到所需要的结果！如果查询时不用<code>*</code>表示字段列表，且名称不一致的字段较少，则可以优先考虑使用别名，如果使用<code>*</code>查询，或者名称不一致的字段较多，则应该优先考虑配置<code>&lt;resultMap&gt;</code>。</strong></p>
<h3 id="7-关联表查询">7. 关联表查询</h3>
<p>创建<code>t_department</code>部门信息表，要求表中存在<code>id</code>和<code>name</code>这2个字段，向表中插入不少于3条数据：</p>
<pre><code>CREATE TABLE t_department (
	id INT AUTO_INCREMENT COMMENT '部门id',
	name VARCHAR(50) NOT NULL UNIQUE COMMENT '部门名称',
	PRIMARY KEY (id)
) DEFAULT CHARSET=UTF8;

INSERT INTO t_department (name) VALUES ('软件研发部'), ('人力资源部'), ('财务部');
</code></pre>
<p>在<code>t_user</code>表中添加<code>department_id</code>字段，为每一个用户数据分配部门id：</p>
<pre><code>ALTER TABLE t_user ADD COLUMN department_id INT;

UPDATE t_user SET department_id=1 WHERE id IN (2,10,17);
UPDATE t_user SET department_id=2 WHERE id IN (16,14,12);
UPDATE t_user SET department_id=3 WHERE id IN (4,13);
</code></pre>
<p>假设存在需求：根据id查询某用户详情，要求直接显示用户所在部门的名称。</p>
<p>首先，直接查询<code>t_user</code>表是不足以得到完整答案的，为了保证数据表管理的规范，在<code>t_user</code>表中只会存储部门的<code>id</code>，并不会存储部门的<code>name</code>，所以，需要实现该需求，就必须使用关联查询：</p>
<pre><code>SELECT 
	t_user.id, username,
	phone, email,
	password, age,
	is_delete AS isDelete,
	department_id AS departmentId,
	name AS departmentName
FROM 
	t_user 
LEFT JOIN
	t_department 
ON 
	department_id=t_department.id
WHERE
	t_user.id=?
</code></pre>
<p>这样的查询可以符合当前需求，但是，在设计代码时，却没有任何一个实体类可以封装以上查询结果！因为实体类都是与数据表一一相对应的，所以就需要另外创建VO(Value Object)类，VO类的设计原则是根据查询结果来确定各属性的：</p>
<pre><code>public class UserVO {
	private Integer id;
	private String username;
	private String password;
	private Integer age;
	private String phone;
	private String email;
	private Integer isDelete;
	private Integer departmentId;
	private String departmentName;
	// SET/GET/hashCode/equals/toString/Serializable
}
</code></pre>
<p>其实，VO类与实体类的设计方式是几乎一样的，只是定位不同，实体类与数据表对应，VO类与查询结果对应。</p>
<p>设计的抽象方法的返回值就应该是<code>UserVO</code>：</p>
<pre><code>UserVO findUserVOById(Integer id);
</code></pre>
<p>然后，配置映射时，需要注意自定义别名，或者配置<code>&lt;resultMap&gt;</code>，同时，注意：如果某个字段名在2张或者涉及的多张表中都存在，必须明确的指定表名，例如这2张表中都有<code>id</code>字段，每次涉及该字段都必须在左侧指定表名：</p>
<pre><code>&lt;select id=&quot;findUserVOById&quot;
	resultType=&quot;cn.tedu.mybatis.UserVO&quot;&gt;
	SELECT 
		t_user.id, username,
		phone, email,
		password, age,
		is_delete AS isDelete,
		department_id AS departmentId,
		name AS departmentName
	FROM 
		t_user 
	LEFT JOIN
		t_department 
	ON 
		department_id=t_department.id
	WHERE
		t_user.id=#{id}
&lt;/select&gt;

查询某个部门的信息，同时，获取该部门中所有用户的信息。
</code></pre>
<p>执行该操作的SQL语句大致是：</p>
<pre><code>SELECT 
	*
FROM
	t_department
LEFT JOIN
	t_user
ON
	t_department.id=t_user.department_id
WHERE
	t_department.id=?
</code></pre>
<p>执行以上查询，可能产生多条结果，因为某1个部门中可能有多个用户！但是，实际需求是“查询某个部门的信息”，结果应该只有1个数据！</p>
<p>为了合理的表示查询结果，可以定义部门信息的VO类<code>cn.tedu.mybatis.DepartmentVO</code>，该类的设计：</p>
<pre><code>public class DepartmentVO {
	private Integer id; // 部门id
	private String name; // 部门名称
	private List&lt;User&gt; users; // 部门中的用户
}
</code></pre>
<p>在开发持久层功能时，由于操作的数据主体不再是“用户”数据，则以前的<code>UserMapper</code>接口就不再适用，应该先创建新的<code>cn.tedu.mybatis.DepartmentMapper</code>持久层接口，并在接口中定义“根据部门id查询部门详情”的抽象方法：</p>
<pre><code>public interface DepartmentMapper {
	
	DepartmentVO findVOById(Integer id);

}
</code></pre>
<p>与添加新的接口的原因相同，也应该给出新的XML文件配置以上抽象方法的SQL语句，所以，可以把原有的<code>UserMapper.xml</code>复制并粘贴，然后重命名为<code>DepartmentMapper.xml</code>，删除原有的配置，再配置以上抽象方法的SQL语句：</p>
<pre><code>&lt;select id=&quot;findVOById&quot; resultType=&quot;xx.xx.xx.DepartmentVO&quot;&gt;
	SELECT 
		t_department.id, name,
		t_user.id, username,
		password, age,
		phone, email,
		is_delete AS isDelete,
		department_id AS departmentId
	FROM
		t_department
	LEFT JOIN
		t_user
	ON
		t_department.id=t_user.department_id
	WHERE
		t_department.id=#{id}
&lt;/select&gt;
</code></pre>
<p>在以上查询结果中，会出现2个名为<code>id</code>的列名，后续在处理数据时，MyBatis将无法正确的区分所需要的<code>id</code>值是哪一列的数据，所以，在查询时，至少需要为以上2个<code>id</code>字段中的1个定义别名，或者将2个都定义不同的别名，保证查询结果中的列名都是唯一的，不会出现冲突：</p>
<pre><code>SELECT 
		t_department.id AS did, name,
		t_user.id AS uid ... ...
</code></pre>
<p>在配置<code>&lt;resultMap&gt;</code>时，关于唯一字段的配置，应该使用<code>&lt;id /&gt;</code>节点进行配置，而不应该使用<code>&lt;result /&gt;</code>节点来配置，2个节点的配置方式完全相同，即使不使用<code>&lt;id /&gt;</code>而使用<code>&lt;result /&gt;</code>也能实现功能，但是，MyBatis是天生自带缓存的，使用<code>&lt;id /&gt;</code>节点配置的数据会作为缓存数据的标识，而使用<code>&lt;result /&gt;</code>节点的配置则不会。</p>
<p>在配置1对多关系时，需要使用<code>&lt;collection&gt;</code>节点，例如1个部门有多个用户，在数据方面，1个部门的VO对象中有1个<code>List</code>集合存储多个<code>User</code>数据。</p>
<p>完整的<code>&lt;resultMap&gt;</code>配置应该是：</p>
<pre><code>&lt;resultMap id=&quot;DepartmentVOMap&quot;
	type=&quot;cn.tedu.mybatis.DepartmentVO&quot;&gt;
	&lt;id column=&quot;did&quot; property=&quot;id&quot;/&gt;
	&lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
	&lt;!-- collection节点：用于配置集合类型的属性 --&gt;
	&lt;!-- property：依然表示类的属性 --&gt;
	&lt;!-- ofType：集合里面放的是什么类型的数据 --&gt;
	&lt;collection property=&quot;users&quot;
		ofType=&quot;cn.tedu.mybatis.User&quot;&gt;
		&lt;!-- column：依然是查询结果中的列名 --&gt;
		&lt;!-- property：ofType的类型中的属性名 --&gt;
		&lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt;
		&lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
		&lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt;
		&lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt;
		&lt;result column=&quot;phone&quot; property=&quot;phone&quot;/&gt;
		&lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt;
		&lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot;/&gt;
		&lt;result column=&quot;department_id&quot; property=&quot;departmentId&quot;/&gt;
	&lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre>
<p>查询节点的配置为：</p>
<pre><code>&lt;select id=&quot;findVOById&quot;
	resultMap=&quot;DepartmentVOMap&quot;&gt;
	SELECT 
		t_department.id AS did, name,
		t_user.id AS uid, username,
		password, age,
		phone, email,
		is_delete, department_id
	FROM
		t_department
	LEFT JOIN
		t_user
	ON
		t_department.id=t_user.department_id
	WHERE
		t_department.id=#{id}
&lt;/select&gt;
</code></pre>
<p>注意：在使用了<code>&lt;resultMap&gt;</code>的查询中，并不需要因为查询结果的列名与类的属性名不同而定义别名，例如以上的<code>is_delete</code>和<code>department_id</code>就没有再定义别名，而只需要为名字冲突的定义别名，例如以上的用户表的id和部门表的id。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis-1]]></title>
        <id>https://guanxuchao.com//post/mybatis-1</id>
        <link href="https://guanxuchao.com//post/mybatis-1">
        </link>
        <updated>2019-07-26T07:42:02.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="21-框架的作用">2.1. 框架的作用</h4>
<p>简化数据库编程，开发者只要指定每项数据操作时的SQL语句及对应的抽象方法即可。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="21-框架的作用">2.1. 框架的作用</h4>
<p>简化数据库编程，开发者只要指定每项数据操作时的SQL语句及对应的抽象方法即可。</p>
<!-- more -->
<h4 id="22-创建springmybatis的项目">2.2. 创建Spring+MyBatis的项目</h4>
<p>创建Maven Project，Group Id为cn.tedu.mybatis，Artifact Id为MyBatis，Packaing选择war。</p>
<p>创建完成后，生成web.xml，添加依赖，添加Tomcat运行环境，复制web.xml中的配置，复制前序项目中的spring.xml(需要删除拦截器的配置)。</p>
<p>然后，需要添加一些新的依赖，首先，添加mybatis的依赖：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.mybatis&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis&lt;/artifactId&gt;
	&lt;version&gt;3.5.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>MyBatis框架是可以独立使用的，但是配置相对繁琐，且没有实际价值，通常都是与Spring结合使用的，甚至结合了SpringMVC，所以，需要添加<code>mybatis-spring</code>的依赖：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.mybatis&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
	&lt;version&gt;2.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>MyBatis的底层是基于jdbc实现的，所以，结合Spring使用后，需要添加<code>spring-jdbc</code>依赖，该依赖的代码与<code>spring-webmvc</code>几乎一样，只是<code>artifact id</code>不同，通常，这2个依赖的版本应该完全相同：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
	&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
	&lt;version&gt;4.3.8.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>还需要添加<code>mysql-connector-java</code>的依赖：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;mysql&lt;/groupId&gt;
	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
	&lt;version&gt;8.0.16&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>另外，还需要<code>commons-dbcp</code>数据库连接池的依赖：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
	&lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
	&lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>最后，检查是否已经添加好了<code>junit</code>依赖，如果已经存在，则跳过，如果没有添加，则补充。</p>
<h4 id="23-配置数据库连接">2.3. 配置数据库连接</h4>
<p>在<strong>src/main/resources</strong>下创建<strong>db.properties</strong>文件，以确定数据库连接的相关配置：</p>
<pre><code>url=jdbc:mysql://localhost:3306/tedu_ums?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai
driver=com.mysql.cj.jdbc.Driver
username=root
password=root
initialSize=2
maxActive=5
</code></pre>
<p>然后，需要在Spring的配置文件中读取以上配置信息：</p>
<pre><code>&lt;!-- 读取db.properties --&gt;
&lt;util:properties id=&quot;dbConfig&quot;
	location=&quot;classpath:db.properties&quot; /&gt;
</code></pre>
<p>最终，程序运行时，需要使用的数据源是<code>BasicDataSource</code>，框架会通过这个类的对象获取数据库连接对象，然后实现数据访问，所以，就需要为这个类的相关属性注入值，把数据库配置信息确定下来：</p>
<pre><code>&lt;!-- 配置数据源 --&gt;
&lt;bean id=&quot;dataSource&quot;
	class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
	&lt;property name=&quot;url&quot; 
		value=&quot;#{dbConfig.url}&quot; /&gt;
	&lt;property name=&quot;driverClassName&quot; 
		value=&quot;#{dbConfig.driver}&quot; /&gt;
	&lt;property name=&quot;username&quot; 
		value=&quot;#{dbConfig.username}&quot; /&gt;
	&lt;property name=&quot;password&quot; 
		value=&quot;#{dbConfig.password}&quot; /&gt;
	&lt;property name=&quot;initialSize&quot; 
		value=&quot;#{dbConfig.initialSize}&quot; /&gt;
	&lt;property name=&quot;maxActive&quot; 
		value=&quot;#{dbConfig.maxActive}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>接下来，可以检验一下以上完成的配置是否正确，则在<strong>src/test/java</strong>下创建<code>cn.tedu.mybatis.Tests</code>测试类，编写并执行测试方法：</p>
<pre><code>@Test
public void getConnection() throws SQLException {
	ClassPathXmlApplicationContext ac
		= new ClassPathXmlApplicationContext(
			&quot;spring.xml&quot;);
	
	BasicDataSource ds = ac.getBean(&quot;dataSource&quot;, BasicDataSource.class);
	
	Connection conn = ds.getConnection();
	System.out.println(conn);
	
	ac.close();
}
</code></pre>
<h4 id="24-设计接口和抽象方法">2.4. 设计接口和抽象方法</h4>
<p>创建<code>cn.tedu.mybatis.User</code>类，类的属性与<code>t_user</code>表保持一致：</p>
<pre><code>public class User {

	private Integer id;
	private String username;
	private String password;
	private Integer age;
	private String phone;
	private String email;

	// SET/GET/toString/hashCode/equals/Serializable

}
</code></pre>
<p>在MyBatis中，要求抽象方法写在接口中，所以，需要先创建<code>cn.tedu.mybatis.UserMapper</code>接口：</p>
<pre><code>public interface UserMapper {
}
</code></pre>
<p>然后，在接口中添加抽象方法，设计原则：</p>
<ul>
<li>
<p>如果要执行的操作是<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>，返回值类型使用<code>Integer</code>，表示受影响的行数；</p>
</li>
<li>
<p>方法的名称可以自定义，但是，不允许重载；</p>
</li>
<li>
<p>参数列表根据执行SQL语句时的不确定数据来设计。</p>
</li>
</ul>
<p>对于要执行的数据操作，先完成“增加”操作，则添加关于“增加”用户数据的抽象方法：</p>
<pre><code>Integer insert(User user);
</code></pre>
<p>然后，需要通过配置，让MyBatis框架知道接口在哪里，所以，在Spring的配置文件中添加配置：</p>
<pre><code>&lt;!-- 配置MapperScannerConfigurer --&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
	&lt;!-- 指定MyBatis所需的接口在哪里 --&gt;
	&lt;property name=&quot;basePackage&quot;
		value=&quot;cn.tedu.mybatis&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="25-配置sql语句">2.5. 配置SQL语句</h4>
<p>下载<code>http://doc.canglaoshi.org/config/mybatis-mapper.zip</code>文件，得到压缩包，在项目的<strong>src/main/resources</strong>下创建名为<strong>mappers</strong>的文件夹，解压下载的压缩包，将得到的xml文件复制到<strong>mappers</strong>文件夹中，并重命名为<strong>UserMapper.xml</strong>。</p>
<p>然后在该文件中配置SQL语句：</p>
<pre><code>&lt;!-- namespace：当前XML文件用于配置哪个接口中抽象方法对应的SQL语句 --&gt;
&lt;mapper namespace=&quot;cn.tedu.mybatis.UserMapper&quot;&gt;

	&lt;!-- 使用insert节点配置插入数据的SQL语句 --&gt;
	&lt;!-- id：抽象方法的方法名 --&gt;
	&lt;!-- 在#{}中间的是方法的参数User类中的属性名称 --&gt;
	&lt;insert id=&quot;insert&quot;&gt;
		INSERT INTO t_user (
			username, password,
			age, phone,
			email
		) VALUES (
			#{username}, #{password},
			#{age}, #{phone},
			#{email}
		)
	&lt;/insert&gt;
	
&lt;/mapper&gt;
</code></pre>
<p>最后，还是需要补充配置，使得MyBatis框架知道这些XML文件在哪里，且执行时使用的数据源是哪一个，则在Spring的配置文件中补充配置：</p>
<pre><code>&lt;!-- SqlSessionFactoryBean --&gt;
&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
	&lt;!-- XML文件在哪里 --&gt;
	&lt;property name=&quot;mapperLocations&quot;
		value=&quot;classpath:mappers/*.xml&quot; /&gt;
	&lt;!-- 使用哪个数据源 --&gt;
	&lt;property name=&quot;dataSource&quot;
		ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>完成之后，在<code>Tests</code>中编写并执行单元测试：</p>
<pre><code>@Test
public void insert() {
	ClassPathXmlApplicationContext ac
		= new ClassPathXmlApplicationContext(
			&quot;spring.xml&quot;);
	
	UserMapper userMapper
		= ac.getBean(&quot;userMapper&quot;, UserMapper.class);
	System.out.println(userMapper.getClass());
	
	User user = new User();
	user.setUsername(&quot;admin&quot;);
	user.setPassword(&quot;1234&quot;);
	Integer rows = userMapper.insert(user);
	System.out.println(&quot;rows=&quot; + rows);
	
	ac.close();
}
</code></pre>
<h4 id="26-实时获取新插入的数据的id">2.6. 实时获取新插入的数据的id</h4>
<p>在配置<code>&lt;insert&gt;</code>节点时，添加<code>useGeneratedKeys=&quot;true&quot;</code>和<code>keyProperty=&quot;id&quot;</code>的配置：</p>
<pre><code>&lt;insert id=&quot;insert&quot;
	useGeneratedKeys=&quot;true&quot;
	keyProperty=&quot;id&quot;&gt;
</code></pre>
<p>然后，执行数据操作后，方法的参数对象中就会被封装自动编号的id值！</p>
<p>以上配置的2个属性，<code>useGeneratedKeys</code>表示“要不要获取自动生成的字段的值，即自动编号的值”，<code>keyProperty</code>表示“获取到的自动编号的值封装在参数对象的哪个属性中”，所以，在本例中，指的是<code>User</code>类中的<code>id</code>属性，并不是<code>t_user</code>表中的<code>id</code>字段。</p>
<blockquote>
<p>通常，Property单词表示“属性”，类才有属性，数据表没有属性，Field表示“字段”，仅当描述数据表结构时才称之为字段，Column表示“列”，仅当描述查询结果时才称之为列。</p>
</blockquote>
<h3 id="-">----------------------------------</h3>
<h3 id="附1如果快速的向数据表中插入已知的1000万条数据">附1：如果快速的向数据表中插入已知的1000万条数据</h3>
<p>假设这1000万条数据在1个<code>List</code>集合中，将这个集合进行遍历，循环1000万次，结合数据库编程技术，就可以将这些数据插入到数据库中。</p>
<p>这样做的缺陷：</p>
<ol>
<li>
<p>在实际工作环境中，应用服务器(程序运行所在的Tomcat服务器)与MySQL数据库服务器并不是同一台服务器，当需要执行数据操作时，会由应用服务器将SQL语句发送到MySQL数据库服务器，发送过程中就需要建立网络连接，才可以发送SQL语句，如果使用以上原始做法，就需要连接1000万次，每次发送1条SQL语句，效率非常低下！</p>
</li>
<li>
<p>每次执行1条SQL语句之前，MySQL服务器还会对SQL语句进行词法分析、语义分析、编译等过程，才可以执行，假设有1000万条SQL语句，则这些词法分析、语义分析、编译等过程就需要经历1000万次！</p>
</li>
</ol>
<p>针对问题1，可以使用批处理来解决，批处理可以一次性发送多条SQL语句到数据库服务器，减少传递SQL语句的次数，从而提高运行效率；</p>
<p>针对问题2，可以把<code>INSERT INTO xx () VALUES ();</code>这种语法调整为<code>INSERT INTO xx () VALUES (值列表1), (值列表2), ..., (值列表N)</code>，这种做法可以使得1条SQL语句插入多条数据，假设每条SQL语句插入了1000条数据，则只需要1万条SQL语句即可！</p>
<p>所以，总的来说，可以使用每条SQL语句插入100条数据，批处理时每次发送1000条这样的SQL语句，整体循环100次，就可以完成所有数据的插入！</p>
<blockquote>
<p>理论上来说，批处理时，不建议一次性处理超过5000条SQL语句。另外，每条SQL语句也不是插入越多数据就越快，拼接这样的SQL语句也是需要耗时的。</p>
</blockquote>
]]></content>
    </entry>
</feed>