<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://guanxuchao.com/</id>
    <title>Chao&apos;s Blog</title>
    <updated>2019-10-16T02:29:13.237Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://guanxuchao.com/"/>
    <link rel="self" href="https://guanxuchao.com//atom.xml"/>
    <subtitle>&lt;h4&gt;个人技术博客&lt;/h4&gt;</subtitle>
    <logo>https://guanxuchao.com//images/avatar.png</logo>
    <icon>https://guanxuchao.com//favicon.ico</icon>
    <rights>All rights reserved 2019, Chao&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[PHP学习]]></title>
        <id>https://guanxuchao.com//post/php-xue-xi</id>
        <link href="https://guanxuchao.com//post/php-xue-xi">
        </link>
        <updated>2019-10-16T02:24:29.000Z</updated>
        <summary type="html"><![CDATA[<ol>
<li>
<h2 id="php基础">PHP基础</h2>
<ol>
<li>
<h4 id="变量规则">变量规则</h4>
<ol>
<li>变量以 $ 符号开头，其后是变量的名称</li>
<li>变量名称必须以字母或下划线开头</li>
<li>变量名称不能以数字开头</li>
<li>变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）</li>
<li>变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）</li>
<li>PHP 没有创建变量的命令，变量会在首次为其赋值时被创建
<ol>
<li>PHP 是一门类型松散的语言，我们不必告知 PHP 变量的数据类型；PHP 根据它的值，自动把变量转换为正确的数据类型；在诸如 C 和 C++ 以及 Java 之类的语言中，程序员必须在使用变量之前声明它的名称和类型。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<ol>
<li>
<h2 id="php基础">PHP基础</h2>
<ol>
<li>
<h4 id="变量规则">变量规则</h4>
<ol>
<li>变量以 $ 符号开头，其后是变量的名称</li>
<li>变量名称必须以字母或下划线开头</li>
<li>变量名称不能以数字开头</li>
<li>变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）</li>
<li>变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）</li>
<li>PHP 没有创建变量的命令，变量会在首次为其赋值时被创建
<ol>
<li>PHP 是一门类型松散的语言，我们不必告知 PHP 变量的数据类型；PHP 根据它的值，自动把变量转换为正确的数据类型；在诸如 C 和 C++ 以及 Java 之类的语言中，程序员必须在使用变量之前声明它的名称和类型。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<!-- more -->
<pre><code>1. #### 变量作用域
	1. 在 PHP 中，可以在脚本的任意位置对变量进行声明，变量的作用域指的是变量能够被引用/使用的那部分脚本。
	2. PHP 有三种不同的变量作用域：
		1. **local（局部）**
			1. 函数内部声明的变量拥有 LOCAL 作用域，只能在函数内部进行访问
		2. **global（全局）**
			1. 函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问
		3. **static（静态）**
			1. 通常，当函数完成/执行后，会删除所有变量。不过，有时我需要不删除某个局部变量。实现这一点需要更进一步的工作；要完成这一点，请在您首次声明变量时使用 static 关键词

1. #### echo 和 print 语句
	1. **echo 和 print 之间的差异**
		1. echo - 能够输出一个以上的字符串。
		2. print - 只能输出一个字符串，并始终返回 1。
		3. echo 比 print 稍快，因为它不返回任何值。
	1. **echo 语句:**
		1.  echo 是一个语言结构，有无括号均可使用：echo 或 echo()。
	1. **print 语句:**
		1. print 也是语言结构，有无括号均可使用：print 或 print()。	

1. #### 数据类型
	1. **字符串:**
		1. 字符串是字符序列，比如 &quot;Hello world!&quot;;字符串可以是引号内的任何文本。您可以使用单引号或双引号
	1. **整数:**
		1. 整数是没有小数的数字。
		1. 整数必须有至少一个数字（0-9）
		2. 整数不能包含逗号或空格
		3. 整数不能有小数点
		4. 整数正负均可
		5. 可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0）
		6. **var_dump()** 会返回变量的数据类型和值
	1. **浮点数：**
		1. 浮点数是有小数点或指数形式的数字。
	1. **逻辑：**
		1. 逻辑是 true 或 false。
	1. **数组：**
		1. 数组在一个变量中存储多个值。
	1. **NULL 值：**
		1. 特殊的 NULL 值表示变量无值。NULL 是数据类型 NULL 唯一可能的值。
		2. NULL 值标示变量是否为空。也用于区分空字符串与空值数据库。
		3. 可以通过把值设置为 NULL，将变量清空。
1. #### 字符串函数：
	1. **strlen() 函数：**
		1. strlen() 函数返回字符串的长度，以字符计。	
		1. strlen() 常用于循环和其他函数，在确定字符串何时结束很重要时。（例如，在循环中，我们也许需要在字符串的最后一个字符之后停止循环）。
	1. **对字符串中的单词计数：**
		1. str_word_count() 函数对字符串中的单词进行计数（空格相隔）
	1. **反转字符串：**
		1. strrev() 函数反转字符串
	1. **strpos() 函数：**
		1. strpos() 函数用于检索字符串内指定的字符或文本。
		2. 如果找到匹配，则会返回首个匹配的字符位置。如果未找到匹配，则将返回 FALSE。
	3. **替换字符串中的文本：**
		1. str_replace() 函数用一些字符串替换字符串中的另一些字符。
1. #### 常量
	1. **常量：**
		1. 常量是单个值的标识符（名称）。在脚本中无法改变该值。
		2. 有效的常量名以字符或下划线开头（常量名称前面没有 $ 符号）。
		3. 与变量不同，**常量贯穿整个脚本**是**自动全局**的。
	4. **设置常量：**
		1. 如需设置常量，请使用 define() 函数 - 它使用三个参数：
			1. 首个参数定义常量的名称
			2. 第二个参数定义常量的值
			3. 可选的第三个参数规定常量名是否对大小写不敏感。默认是 false。
1. #### 运算符
	1. **算数运算符:**&lt;br&gt;
		![avatar](D:\Java\Blog\图片\PHP\php算数运算符.jpg)
	1. **赋值运算符:**&lt;br&gt;
		![avatar](D:\Java\Blog\图片\PHP\php赋值运算符.jpg)
	1. **字符串运算符:**&lt;br&gt;
	 	![avatar](D:\Java\Blog\图片\PHP\php字符串运算符.jpg)
	1. **递增/递减运算符:**&lt;br&gt;
		![avatar](D:\Java\Blog\图片\PHP\php递增递减运算符.jpg)
	1. **比较运算符:**&lt;br&gt;
		![avatar](D:\Java\Blog\图片\PHP\php比较运算符.jpg)
	1. **逻辑运算符:**&lt;br&gt;
		![avatar](D:\Java\Blog\图片\PHP\php逻辑运算符.jpg)
	1. **数组运算符:**&lt;br&gt;
		![avatar](D:\Java\Blog\图片\PHP\php数组运算符.jpg)

1. #### 条件语句
	1. **if 语句** - 如果指定条件为真，则执行代码
		1. if 语句用于**在指定条件为 true 时**执行代码。
	2. **if...else 语句** - 如果条件为 true，则执行代码；如果条件为 false，则执行另一端代码
		1. if....else 语句**在条件为 true 时执行代码，在条件为 false 时执行另一段代码**。
	3. **if...elseif....else 语句** - 根据两个以上的条件执行不同的代码块
		1. if....elseif...else 语句来**根据两个以上的条件执行不同的代码**。
	4. **switch 语句** - 选择多个代码块之一来执行
		1. 当希望**有选择地执行若干代码块之一**，请使用 Switch 语句。
		2. 使用 Switch 语句可以避免冗长的 if..elseif..else 代码块。
1. #### 循环	
	1. **while:**- 只要指定条件为真，则循环代码块
		1. `while (条件为真) {要执行的代码;}`
	2. **do...while:** - 先执行一次代码块，然后只要指定条件为真则重复循环
		1. `do {要执行的代码;} while (条件为真);`
	3. **for:** - 循环代码块指定次数
		1. `for (init counter; test counter; increment counter) {code to be executed;}`
			1. init counter：初始化循环计数器的值
			2. test counter：: 评估每个循环迭代。如果值为 TRUE，继续循环。如果它的值为 FALSE，循环结束。
			3. increment counter：增加循环计数器的值
	4. **for each:**- 遍历数组中的每个元素并循环代码块
		1. foreach 循环只适用于**数组**，并用于遍历数组中的每个键/值对。
		2. `foreach ($array as $value) {code to be executed;}`
1. ### 函数
	1.  PHP 的真正力量来自它的函数：它拥有超过 1000 个内建的函数。
	2.  **用户定义函数**
		1.  除了内建的 PHP 函数，我们可以创建我们自己的函数。
		2.  函数是可以在程序中重复使用的语句块。
		3.  页面加载时函数不会立即执行。
		4.  函数只有在被调用时才会执行。
	5.  **创建用户定义函数：**
		1.  用户定义的函数声明以单词 &quot;function&quot; 开头：
			1.  `function functionName() {被执行的代码;}`
		2.  函数名能够以字母或下划线开头（而非数字）。
		3.  函数名对大小写不敏感。
		4.  函数名应该能够反映函数所执行的任务。
		5.  如需调用该函数，只要使用函数名即可
	6.  **函数参数：**
		1.  可以通过参数向函数传递信息。参数类似变量。
		2.  参数被定义在函数名之后，括号内部。您可以添加任意多参数，只要用逗号隔开即可。
	3.  **默认参数值：**
		1.  可以给参数设置默认值，当调用没有参数的函数时，它的参数会取默认值
	2.  **函数 - 返回值：**
		1.  如需使函数返回值，可以使用 return 语句
2. ### 数组
	1. 数组能够在单独的变量名中存储一个或多个值。数组是特殊的变量，它可以同时保存一个以上的值。
	2. **创建数组:**
		1. 在 PHP 中， array() 函数用于创建数组：
	2. **数组类型：**
		1. **索引数组** - 带有数字索引的数组
			1. 有两种创建索引数组的方法：
				2. 索引自动分配（索引从0开始）
					1. `$cars=array(&quot;porsche&quot;,&quot;BMW&quot;,&quot;Volvo&quot;);`
				3. 手动分配索引
					1. `$cars[0]=&quot;porsche&quot;;$cars[1]=&quot;BMW&quot;;$cars[2]=&quot;Volvo&quot;;`
			2. 获得数组的长度 - count() 函数
				1. count(数组名) 函数用于返回数组的长度（元素数）
			2. 遍历索引数组
				1. 利用for循环和 count()函数 遍历数组
		2. **关联数组** - 带有指定键的数组
			1. 关联数组是使用您分配给数组的指定键的数组。(类似于key value)
			2. 有两种创建关联数组的方法：
				1. `$age=array(&quot;Bill&quot;=&gt;&quot;35&quot;,&quot;Steve&quot;=&gt;&quot;37&quot;,&quot;Elon&quot;=&gt;&quot;43&quot;);`	
				2. `$age['Bill']=&quot;63&quot;;$age['Steve']=&quot;56&quot;;$age['Elon']=&quot;47&quot;;`
			3. 遍历关联数组
				1. 利用 foreach 循环：
				2. `$age=array(&quot;Bill&quot;=&gt;&quot;63&quot;,&quot;Steve&quot;=&gt;&quot;56&quot;,&quot;Elon&quot;=&gt;&quot;47&quot;);`&lt;br&gt;`foreach($age as $x=&gt;$x_value) {echo &quot;Key=&quot; . $x . &quot;, Value=&quot; . $x_value;echo &quot;&lt;br&gt;&quot;;}`
		3. **多维数组** - 包含一个或多个数组的数组
4.  #### 数组排序
	1.  **数组的排序函数：**
		1.  **对数组进行升序排序 - sort()：**
			1.  **sort(数组名)：**可按照字母和数字进行升序(A-Z,0-9)
		2.  **对数组进行降序排序 - rsort()：**
			1.  **rsort(数组名)：**可按照字母和数字进行升序(Z-A,9-0)
		3.  **根据值对数组进行升序排序 - asort()：**
			1.  **asort(数组名)：**根据值的大小对关联数组进行升序排序
		4.  **根据键对数组进行升序排序 - ksort()：**
			1.  **ksort(数组名)：**根据键的字母顺序对关联数组进行升序排序
		5.  **根据值对数组进行降序排序 - arsort()：**
			1.  **arsort(数组名)：**根据值的大小对关联数组进行降序排序
		6.  **根据键对数组进行降序排序 - krsort()：**
			1.  **krsort(数组名)：**根据键的字母顺序对关联数组进行降序排序

2.  #### 全局变量 - 超全局变量 
	1.  超全局变量在 PHP 4.1.0 中引入，是在全部作用域中始终可用的内置变量。
	1.  **全局变量 - 超全局变量：**
		1.  PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们。
		2.  **$GLOBALS — 引用全局作用域中可用的全部变量：**
			1.  $GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。
			2.  PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。
		3.  **$_SERVER：**
			1.  $_SERVER 这种超全局变量保存关于报头、路径和脚本位置的信息。&lt;br&gt;
				![avatar](D:\Java\Blog\图片\PHP\php$_SERVER函数.jpg)
		4.  **$_REQUEST：**
			1.  $_REQUEST 用于收集 HTML 表单提交的数据。
		5.  **$_POST：**
			1.  $_POST 广泛用于收集提交 method=&quot;post&quot; 的 HTML 表单后的表单数据。$_POST 也常用于传递变量。
		6.  **$_GET：**
			1.  $_GET 也可用于收集提交 HTML 表单 (method=&quot;get&quot;) 之后的表单数据。
			2.  $_GET 也可以收集 URL 中的发送的数据。
		7.  **：**
		8.  **：**
		9.  **：**
		10.  **：**
11.  #### 表单处理
	1.  **一个简单的 HTML 表单:**
		1.  下面的例子显示了一个简单的 HTML 表单，它包含两个输入字段和一个提交按钮：&lt;br&gt;
			![avatar](D:\Java\Blog\图片\PHP\php表单post.jpg)&lt;br&gt;
		当用户填写此表单并点击提交按钮后，表单数据会发送到名为 &quot;welcome.php&quot; 的 PHP 文件供处理。表单数据是通过 HTTP POST 方法发送的。&lt;br&gt;
		如需显示出被提交的数据，您可以简单地输出（echo）所有变量。&quot;welcome.php&quot; 文件是这样的：&lt;br&gt;
			![avatar](D:\Java\Blog\图片\PHP\phppost表单.jpg)&lt;br&gt;
		输出：&lt;br&gt;
			![avatar](D:\Java\Blog\图片\PHP\php表单输出.jpg)&lt;br&gt;
		使用 HTTP GET 方法也能得到相同的结果：&lt;br&gt;
			![avatar](D:\Java\Blog\图片\PHP\php表单get.jpg)&lt;br&gt;
		&quot;welcome_get.php&quot; 是这样的：&lt;br&gt;
			![avatar](D:\Java\Blog\图片\PHP\phpget表单.jpg)&lt;br&gt;
		1. **上面的代码很简单。不过，最重要的内容被漏掉了。需要对表单数据进行验证，以防止脚本出现漏洞。**
	2.  **GET vs. POST:**
		1.  GET 和 POST 都创建数组（例如，array( key =&gt; value, key2 =&gt; value2, key3 =&gt; value3, ...)）。此数组包含键/值对，其中的键是表单控件的名称，而值是来自用户的输入数据。
		2.  GET 和 POST 被视作 $_GET 和 $_POST。它们是超全局变量，这意味着对它们的访问无需考虑作用域 - 无需任何特殊代码，您能够从任何函数、类或文件访问它们。
		3.  $_GET 是通过 URL 参数传递到当前脚本的变量数组。
		4.  $_POST 是通过 HTTP POST 传递到当前脚本的变量数组。
	3.  **何时使用 GET？:**
		1.  通过 GET 方法从表单发送的信息**对任何人都是可见的**（所有变量名和值都显示在 URL 中）。GET 对所发送信息的数量也有限制。限制在大约 2000 个字符。不过，由于变量显示在 URL 中，把页面添加到书签中也更为方便。
		2.  GET 可用于发送非敏感的数据。
		3.  **绝不能使用 GET 来发送密码或其他敏感信息！**
	4.  **何时使用 POST？:**
		1.  通过 POST 方法从表单发送的信息**对其他人是不可见的**（所有名称/值会被嵌入 HTTP 请求的主体中），并且对所发送信息的数量也**无限制**。
		2.  此外 POST 支持高阶功能，比如在向服务器上传文件时进行 multi-part 二进制输入。
		3.  不过，由于变量未显示在 URL 中，也就无法将页面添加到书签。</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阻塞队列&二叉树]]></title>
        <id>https://guanxuchao.com//post/zu-sai-dui-lie-ander-cha-shu</id>
        <link href="https://guanxuchao.com//post/zu-sai-dui-lie-ander-cha-shu">
        </link>
        <updated>2019-08-18T07:47:45.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="1生产者-消息者模型与阻塞队列">1.生产者、消息者模型与阻塞队列</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="1生产者-消息者模型与阻塞队列">1.生产者、消息者模型与阻塞队列</h1>
<!-- more -->
<h2 id="1什么是生产者">(1)什么是生产者?</h2>
<pre><code>生产者负责产生数据。
</code></pre>
<h2 id="2什么是消费者">(2)什么是消费者?</h2>
<pre><code>消费者负责消费数据。
</code></pre>
<h2 id="3生产者-消费者模型用来解决什么问题">(3)生产者、消费者模型用来解决什么问题?</h2>
<pre><code>用来解决生产者生产数据与消费者消费数据
不同步的问题。
生产者产生数据之后，将这些数据存放到阻塞
队列里面，消息者从阻塞队列当中取出数据。
</code></pre>
<h2 id="4什么是阻塞队列">(4)什么是阻塞队列?</h2>
<pre><code>阻塞队列可以在多线程环境下使用，当阻塞队列满时，
生产者线程会阻塞（即暂时挂起)。当阻塞队列为空时，
消费者线程会阻塞。
阻塞队列一般都解决了线程安全问题。
</code></pre>
<p><img src="https://guanxuchao.com//post-images/1566402565227.png" alt=""></p>
<h2 id="5生产者-消费者模型的经典使用场合">(5)生产者、消费者模型的经典使用场合</h2>
<pre><code>a.订单处理
	订单信息先写入到阻塞队列，然后消息者
	线程从阻塞队列中取出数据，写到数据库。
b.应用服务器设计(用于任务的分派)
</code></pre>
<p><img src="https://guanxuchao.com//post-images/1566402579830.png" alt=""></p>
<pre><code>c.日志
	可以让生产者线程将日志信息先写入阻塞
	队列，然后让消息者线程从阻塞队列当中取
	出日志信息，然后写入数据库。　
</code></pre>
<h2 id="6经典案例日志处理">(6)经典案例(日志处理)</h2>
<p><img src="https://guanxuchao.com//post-images/1566402586852.png" alt=""></p>
<h2 id="7相关的接口与类">(7)相关的接口与类</h2>
<pre><code>BlockingQueue接口
	注：该接口继承Queue接口。
LinkedBlockingQueue类
	注：底层实现是一个链表，每添加一个消息(数据),
	就需要创建一个新的结点，如果并发量很大，
	可能会影响系统GC。
	除此之外，LinkedBlockQueue的put方法和
	take方法用的是不同的锁，并发性能比较好。
ArrayBlockingQueue类
	注：底层实现是一个数组。
	ArrayBlockingQueue的take方法和put方法
	用的是同一个锁，并发性能差一些。
</code></pre>
<h1 id="练习">练习</h1>
<pre><code>Producer线程每隔5秒向阻塞队列当中添加一个
随机数。Consumer线程每隔2秒从阻塞队列当中
取出随机数然后输出。
Producer类(Producer线程类)
Consumer类(Consumer线程类)
Test类(启动Producer线程和Consumer线程)
</code></pre>
<h1 id="2二叉树">2.二叉树</h1>
<h2 id="1什么是二叉树">(1)什么是二叉树?</h2>
<pre><code>任意一个节点，最多只有两棵子树的树结构。
注：
	这两棵子树一般称之为左子树和右子树。
</code></pre>
<p><img src="https://guanxuchao.com//post-images/1566402676075.png" alt=""></p>
<h2 id="2排序二叉树搜索二叉树">(2)排序二叉树(搜索二叉树)</h2>
<pre><code>任意一个节点，其左子树上的节点值比该节点的
值小，其右子树上的节点值比该节点的值要大。
左右子树也是一个排序二叉树。
注：
	排序二叉树不允许出现重复元素。
</code></pre>
<p><img src="https://guanxuchao.com//post-images/1566402603064.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Servlet九大内置对象]]></title>
        <id>https://guanxuchao.com//post/servlet-jiu-da-nei-zhi-dui-xiang</id>
        <link href="https://guanxuchao.com//post/servlet-jiu-da-nei-zhi-dui-xiang">
        </link>
        <updated>2019-08-17T15:15:20.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">隐式对象</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">request</td>
<td style="text-align:left">转译后对应HttpServletRequest/ServletRequest对象</td>
</tr>
<tr>
<td style="text-align:left">response</td>
<td style="text-align:left">转译后对应HttpServletRespons/ServletResponse对象</td>
</tr>
<tr>
<td style="text-align:left">session</td>
<td style="text-align:left">转译后对应HttpSession对象</td>
</tr>
<tr>
<td style="text-align:left">application</td>
<td style="text-align:left">转译后对应ServletContext对象</td>
</tr>
<tr>
<td style="text-align:left">out</td>
<td style="text-align:left">转译后对应JspWriter对象，其内部关联一个PringWriter对象</td>
</tr>
<tr>
<td style="text-align:left">page</td>
<td style="text-align:left">转译后对应this</td>
</tr>
<tr>
<td style="text-align:left">config</td>
<td style="text-align:left">转译后对应ServletConfig对象</td>
</tr>
<tr>
<td style="text-align:left">pageContext</td>
<td style="text-align:left">转译后对应PageContext对象，它提供了JSP页面资源的封装，并可设置页面范围属性</td>
</tr>
<tr>
<td style="text-align:left">exception</td>
<td style="text-align:left">转译后对应Throwable对象，代表由其他JSP页面抛出的异常对象，只会出现于JSP错误页面(isErrorPage设置为true的JSP页面)</td>
</tr>
</tbody>
</table>
<h2 id="jsp隐含变量">Jsp隐含变量</h2>
<p>1、out 来源于Java.io.Writer类，它用于发送输出流到客户端。<br>
2、request 来源于javax.servlet.http.HttpServletRequest接口。它被关联到每一个HTTP请求。<br>
3、response 来源于javax.servlet.http.HttpServletResponse。response对象用于把取得的数据返回到客户端。<br>
4、pageContext 提供访问JSP页面的命名空间。它也提供用来访问其他的JSP隐含对象。<br>
5、session 来源于javax.servlet.http.HttpSession。它用于存储客户端请求的信息，因此它是有状态交互式的。<br>
6、application 来源于javax.servlet.ServletContext。<br>
7、config 来源于ServletConfig，它包含了当前JSP/Servlet所在的WEB应用的配置信息。<br>
8、page 来源于当前被访问JSP页面的实例化。它实际使用的是JSP转换成的Servlet。<br>
9、exception 用于捕获JSP抛出的异常。它只有在JSP页面属性isErrorPage=true时才可用。</p>
<h2 id="jsp九种内置对象">JSP九种内置对象：</h2>
<h4 id="一-request对象">一  request对象：</h4>
<p>该对象封装了用户提交的信息，通过调用该对象相应的方法可以获取封装的信息， 即使用该对象可以获取用户提交信息。 客户端的请求参数都被封装到这个对象里面</p>
<h4 id="二-response对象">二  response对象：</h4>
<p>对客户的请求做出动态的响应，向客户端发送数据。</p>
<h4 id="三-session对象">三  session对象</h4>
<p>1.什么是session：session对象是一个JSP内置对象，它在第一个JSP页面被装载时自动创建，完成会话期管理。<br>
从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。当一个客户访问一个服务器时，可能会在这个服务器的几个页面之间反复连接，反复刷新一个页面，服务器应当通过某种办法知道这是同一个客户，这就需要session对象。<br>
2．session对象的ID：当一个客户首次访问服务器上的一个JSP页面时，JSP引擎产生一个session对象，同时分配一个String类型的ID号，JSP引擎同时将这个ID号发送到客户端，存放在Cookie中，这样session对象和客户之间就建立了一一对应的关系。当客户再访问连接该服务器的其他页面时，不再分配给客户新的session对象，直到客户关闭浏览器后，服务器端该客户的session对象才取消，并且和客户的会话对应关系消失。当客户重新打开浏览器再连接到该服务器时，服务器为该客户再创建一个新的session对象。</p>
<h4 id="四-aplication对象">四  aplication对象</h4>
<p>1．什么是application:<br>
服务器启动后就产生了这个application对象，当客户在所访问的网站的各个页面之间浏览时，这个application对象都是同一个，直到服务器关闭。但是与session不同的是，所有客户的application对象都是同一个，即所有客户共享这个内置的application对象。<br>
2．application对象常用方法:<br>
(1)public void setAttribute(String key,Object obj): 将参数Object指定的对象obj添加到application对象中，并为添加的对象指定一个索引关键字。<br>
(2)public Object getAttribute(String key): 获取application对象中含有关键字的对象。</p>
<h4 id="五-out对象">五 out对象</h4>
<p>out 对象是一个输出流，用来向客户端输出数据。out对象用于各种数据的输出。</p>
<h4 id="六-page-javalangobject">六  page java.lang.Object</h4>
<p>对应this关键字。JSP网页本身<br>
page对象是当前页面转换后的Servlet类的实例。从转换后的Servlet类的代码中，可以看到这种关系：<br>
Object page = this;<br>
在JSP页面中，很少使用page对象。</p>
<h4 id="七-config">七  config</h4>
<p>javax.servlet. ServletConfig 的实例，该实例代表该JSP 的配置信息。常用的方法有getInitPararneter(String paramNarne) 及getInitPararneternarnes() 等方法。事实上， JSP 页面通常无须配置，也就不存在配置信息。因此，该对象更多地在Servlet 中有效。</p>
<h4 id="八-exception-javalangthrowable-的实例">八  exception java.lang.Throwable 的实例</h4>
<p>该实例代表其他页面中的异常和错误。只有当页面是错误处理页面，即编译指令page 的isErrorPage 属性为true 时，该对象才可以使用。常用的方法有getMessageO和printStackTraceO等。</p>
<h4 id="九-pagecontext">九  pageContext</h4>
<p>javax.servlet.jsp.PageContext 的实例，对象直译时可以称作“页面上下文”对象，代表的是当前页面运行的一些属性，通过此对象可以拿到其他8大对象，使用该对象可以访问页面中的共享数据。常用的方法有getServletContextO和getServletConfigO等。</p>
<h2 id="四个作用域request域-session域-application域-page域">四个作用域：request域  session域  application域  page域</h2>
<h4 id="application">application：</h4>
<p>全局作用范围，整个应用程序共享，就是在部署文件中的同一个webApp共享，生命周期为：应用程序启动到停止。</p>
<h4 id="session">session：</h4>
<p>会话作用域，当用户首次访问时，产生一个新的会话，以后服务器就可以记住这个会话状态。生命周期：会话超时，或者服务器端强制使会话失效。</p>
<h4 id="request">request：</h4>
<p>请求作用域，就是客户端的一次请求。</p>
<h4 id="page">page：</h4>
<p>一个JSP页面。</p>
<p>以上作用范围使越来越小， request和page的生命周期都是短暂的，他们之间的区别就是：一个request可以包含多个page页(include，forward以及filter)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot与Spring MVC的区别[转]]]></title>
        <id>https://guanxuchao.com//post/spring-boot-yu-spring-mvc-de-qu-bie</id>
        <link href="https://guanxuchao.com//post/spring-boot-yu-spring-mvc-de-qu-bie">
        </link>
        <updated>2019-08-11T08:56:30.000Z</updated>
        <summary type="html"><![CDATA[<p>Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。</p>
<!-- more -->
<p>但他们的基础都是Spring 的 ioc和 aop ioc 提供了依赖注入的容器 aop ，解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。Spring MVC是基于 Servlet 的一个 MVC 框架 主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种XML、 JavaConfig、hin处理起来比较繁琐。于是为了简化开发者的使用，从而创造性地推出了Spring boot，约定优于配置，简化了spring的配置流程。</p>
<p>说得更简便一些：Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。</p>
<h3 id="spring-mvc的功能">Spring MVC的功能</h3>
<pre><code>Spring MVC提供了一种轻度耦合的方式来开发web应用。
</code></pre>
<p>Spring MVC是Spring的一个模块，式一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。</p>
<h3 id="spring-boot的功能">Spring Boot的功能</h3>
<pre><code>Spring Boot实现了自动配置，降低了项目搭建的复杂度。
</code></pre>
<p>众所周知Spring框架需要进行大量的配置，Spring Boot引入自动配置的概念，让项目设置变得很容易。Spring Boot本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，Spring Boot应用中这些第三方库几乎可以零配置的开箱即用(out-of-the-box)，大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p>
<p>Spring Boot只是承载者，辅助你简化项目搭建过程的。如果承载的是WEB项目，使用Spring MVC作为MVC框架，那么工作流程和你上面描述的是完全一样的，因为这部分工作是Spring MVC做的而不是Spring Boot。</p>
<p>对使用者来说，换用Spring Boot以后，项目初始化方法变了，配置文件变了，另外就是不需要单独安装Tomcat这类容器服务器了，maven打出jar包直接跑起来就是个网站，但你最核心的业务逻辑实现与业务流程实现没有任何变化。</p>
<pre><code>所以，用最简练的语言概括就是： 	

Spring 是一个“引擎”； 

Spring MVC 是基于Spring的一个 MVC 框架 ；

Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。
</code></pre>
<p><br>链接：https://www.zhihu.com/question/64671972/answer/223383505</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表]]></title>
        <id>https://guanxuchao.com//post/lian-biao</id>
        <link href="https://guanxuchao.com//post/lian-biao">
        </link>
        <updated>2019-08-10T07:47:25.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="1什么是链表">1.什么是链表?</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="1什么是链表">1.什么是链表?</h1>
<!-- more -->
<pre><code>链表由一系列节点构成，其中，每个节点
包含两部分内容(一部分是数据，另外一部分是
指针）。
注:
	指针指向了下一个节点(也就是说通过该指针
可以找到下一个节点)。
	如果只有一个指向下一个节点的指针，称之为
单向链表。
	如果有两个指针(一个指向上一个节点，一个指)
向下一个节点)，称之为两向链表。
	如果最后一个节点与第一个节点也通过指针
连接起来，称之为双向循环链表。
</code></pre>
<p><img src="https://guanxuchao.com//post-images/1565882087342.png" alt=""></p>
<h1 id="2链表跟数组相比优缺点是什么">2.链表跟数组相比，优缺点是什么?</h1>
<pre><code>数组的优点:
	依据下标可以非常快速的找到某个元素。
数组的缺点:
	删除和插入操作比较耗费时间，需要重新
移动大量元素(包括扩容)。
	数组需要有连续的地址空间。

链表的优点:
	删除和插入操作速度非常快。
	链表不需要连续的地址空间。
链表的缺点:
	依据下标查找某个元素比较慢。			
	链表节点需要保存节点的地址，同数组相比，
	需要占用更多的内存。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot]]></title>
        <id>https://guanxuchao.com//post/springboot</id>
        <link href="https://guanxuchao.com//post/springboot">
        </link>
        <updated>2019-08-03T07:46:18.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="1-springboot的作用">1. SpringBoot的作用</h3>
<p>SpringBoot是默认整合了Spring、SpringMVC及相关常用框架的一个综合性框架，大量的减少了相关的配置，使得创建项目和使用变得更加简单。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="1-springboot的作用">1. SpringBoot的作用</h3>
<p>SpringBoot是默认整合了Spring、SpringMVC及相关常用框架的一个综合性框架，大量的减少了相关的配置，使得创建项目和使用变得更加简单。</p>
<!-- more -->
<p>在常规配置方面，SpringBoot的思想是“约定大于配置”，即：大多数开发者都会使用某种配置方式的话，则SpringBoot就会直接配置成那个样子，然后，开发者在使用SpringBoot时就不用再进行相关配置，只需要知道已经被配置为那个样子了就可以了！</p>
<h3 id="2-创建springboot项目">2. 创建SpringBoot项目</h3>
<p>需要打开浏览器，访问<code>https://start.spring.io/</code>，填写创建项目的参数，配置完成后，点击<strong>Generate the project</strong>即可生成项目。</p>
<p>解压缩下载得到的压缩包，其中的文件夹就是项目文件夹，推荐将该文件夹移动到Workspace中，然后通过Eclipse的<strong>Import</strong> -&gt; <strong>Exsiting Maven Projects</strong>导入该项目，务必保证当前可以连接到Maven服务器，导入后，会自动下载大量依赖，直至项目结构完整。</p>
<h3 id="3-springboot-helloworld">3. SpringBoot HelloWorld</h3>
<p>在<strong>src/main/resources</strong>下默认已经存在<strong>static</strong>的文件夹，该文件是SpringBoot项目用于存放静态资源的文件夹，例如存放<code>.html</code>文件、图片、<code>.css</code>文件、<code>.js</code>文件等，相当于传统项目中的<strong>webapp</strong>文件夹，则可以在<strong>static</strong>创建<strong>index.html</strong>欢迎页面。</p>
<p>在<strong>src/main/java</strong>下默认已经存在<code>cn.tedu.springboot.sample</code>包，该包名是根据创建项目时的参数决定的，这个包就是当前项目的根包(Base-Package)，并且在该包下已经存在<code>SampleApplication.java</code>文件，该文件的名称也是根据创建项目时填写的<strong>artifact</strong>决定的，该文件中包含<code>main()</code>方法，直接执行<code>main()</code>方法就可以启动当前项目，所以，该类也是SpringBoot的启动类！</p>
<p>SpringBoot项目在启动时会启动内置的Tomcat，默认占用8080端口，如果此前该端口已经处于占用状态，则项目会启动失败！</p>
<p>通过<code>http://localhost:8080</code>即可访问所涉及的网页，由于SpringBoot项目内置Tomcat，该Tomcat只为当前项目服务，所以启动时设置的Context Path是空字符串，在访问时URL中不必添加项目名称，而<strong>index.html</strong>是默认的欢迎页面，其文件名也不必体现在URL中！</p>
<h3 id="4-springboot-mybatis环境">4. SpringBoot + MyBatis环境</h3>
<p>SpringBoot项目默认没有集成持久层相关依赖，需要手动补充，或者创建项目时就选中：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
	&lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
	&lt;groupId&gt;mysql&lt;/groupId&gt;
	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
	&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>当添加以上依赖之后，SpringBoot项目再启动时就会尝试读取连接数据库的相关配置，如果还没有配置，则会启动失败！</p>
<p>在<strong>src/main/resources</strong>下有<strong>application.properties</strong>，该文件就是SpringBoot的配置文件，在该文件中添加配置：</p>
<pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/tedu_ums?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
<blockquote>
<p>一般情况下，不需要配置连接数据库的driverClassName，因为SpringBoot会自动从jar中读取！</p>
</blockquote>
<p>添加以上配置后，项目可以正常启动，但是，如果以上配置信息是错误的，也不影响启动过程，也就是说，SpringBoot启动时，会读取相关配置，但是，并不执行数据库连接，所以，就算是配置错误也并不会体现出来。</p>
<h3 id="5-测试数据库连接">5. 测试数据库连接</h3>
<p>在<strong>src/test/java</strong>下，默认已经存在项目的根包及测试类，且测试类中已经存在一个空的测试方法：</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class SampleApplicationTests {

	@Test
	public void contextLoads() {
	}

}
</code></pre>
<p>可以先执行以上<code>contextLoads()</code>方法的单元测试，如果测试出错，一定是测试环境或者框架环境有问题，多考虑为jar包已经损坏，应该重新下载或者更换版本！</p>
<p>可以在该测试类中编写单元测试：</p>
<pre><code>@Autowired
private DataSource dataSource;

@Test
public void getConnection() throws SQLException {
	Connection conn = dataSource.getConnection();
	System.err.println(conn);
}
</code></pre>
<p>如果测试通过，则此前配置的数据库连接信息是正确的！</p>
<h3 id="6-注册功能的持久层接口">6. 注册功能的持久层接口</h3>
<p>先创建与数据表对应的实体类<code>cn.tedu.springboot.sample.entity.User</code>：</p>
<pre><code>public class User implements Serializable {

	private static final long serialVersionUID = 7019981109167736281L;

	private Integer id;
	private String username;
	private String password;
	private Integer age;
	private String phone;
	private String email;
	private Integer isDelete;
	private Integer departmentId;

	// ...
}
</code></pre>
<p>然后，创建持久层接口<code>cn.tedu.springboot.sample.mapper.UserMapper</code>：</p>
<pre><code>public interface UserMapper {
	
	Integer insert(User user);
	
	User findByUsername(String username);

}
</code></pre>
<p>为了保证MyBatis框架能确定接口文件的位置，可以在接口的声明之前添加<code>@Mapper</code>注解，不过，这样的做法就要求每一个持久层接口之前都需要添加该注解，也可以在启动类<code>SampleApplication</code>之前添加<code>@MapperScan</code>注解进行配置，则后续只需要把持久层接口都放在这个包中就可以了，无需反复添加注解：</p>
<pre><code>@SpringBootApplication
@MapperScan(&quot;cn.tedu.springboot.sample.mapper&quot;)
public class SampleApplication {

	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}

}
</code></pre>
<h3 id="7-注册功能的映射">7. 注册功能的映射</h3>
<p>可以在每一个抽象方法之前使用注解配置所对应的SQL语句，例如：</p>
<pre><code>@Options(useGeneratedKeys=true, keyProperty=&quot;id&quot;)
@Insert(&quot;insert into t_user (字段列表) values (值列表)&quot;)
Integer insert(User user);
</code></pre>
<p>这种做法是MyBatis本身就支持的，并不是SpringBoot所特有的！这种做法最大的优点在于：对应关系非常直观。主要的缺陷在于：配置长篇的SQL语句时，代码不易于阅读和维护！所以，一般仍然推荐使用XML配置映射的SQL语句！</p>
<p>与此前一样，在<strong>src/main/resources</strong>下创建名为<strong>mappers</strong>的文件夹，然后使用<strong>UserMapper.xml</strong>进行配置：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  
&lt;!DOCTYPE mapper PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot;      
	&quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&gt;

&lt;!-- namespace：当前XML文件用于配置哪个接口中抽象方法对应的SQL语句 --&gt;
&lt;mapper namespace=&quot;cn.tedu.springboot.sample.mapper.UserMapper&quot;&gt;

	&lt;!-- resultMap节点：指导MyBatis如何封装查询结果 --&gt;
	&lt;!-- id：自定义名称 --&gt;
	&lt;!-- column：查询结果中的列名 --&gt;
	&lt;!-- property：type对应的类中的属性名 --&gt;
	&lt;resultMap id=&quot;UserEntityMap&quot;
		 type=&quot;cn.tedu.springboot.sample.entity.User&quot;&gt;
		&lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
		&lt;result column=&quot;username&quot; property=&quot;username&quot; /&gt;
		&lt;result column=&quot;password&quot; property=&quot;password&quot; /&gt;
		&lt;result column=&quot;age&quot; property=&quot;age&quot; /&gt;
		&lt;result column=&quot;phone&quot; property=&quot;phone&quot; /&gt;
		&lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;
		&lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot; /&gt;
		&lt;result column=&quot;department_id&quot; property=&quot;departmentId&quot; /&gt;
	&lt;/resultMap&gt;

	&lt;!-- 使用insert节点配置插入数据的SQL语句 --&gt;
	&lt;!-- id：抽象方法的方法名 --&gt;
	&lt;!-- 在#{}中间的是方法的参数User类中的属性名称 --&gt;
	&lt;insert id=&quot;insert&quot;
		useGeneratedKeys=&quot;true&quot;
		keyProperty=&quot;id&quot;&gt;
		INSERT INTO t_user (
			username, password,
			age, phone,
			email, is_delete,
			department_id
		) VALUES (
			#{username}, #{password},
			#{age}, #{phone},
			#{email}, #{isDelete},
			#{departmentId}
		)
	&lt;/insert&gt;
	
	&lt;select id=&quot;findByUsername&quot;
		resultMap=&quot;UserEntityMap&quot;&gt;
		SELECT 
			* 
		FROM 
			t_user 
		WHERE 
			username=#{username} 
	&lt;/select&gt;
	
&lt;/mapper&gt;
</code></pre>
<p>另外，还需要配置XML文件的位置，则打开<strong>application.properties</strong>文件添加配置：</p>
<pre><code>mybatis.mapper-locations=classpath:mappers/*.xml
</code></pre>
<h3 id="8-持久层单元测试">8. 持久层单元测试</h3>
<p>在<strong>src/test/java</strong>下创建<code>cn.tedu.springboot.sample.mapper.UserMapperTests</code>单元测试类，将默认存在的<code>SampleApplicationTests</code>类之前的2行注解复制到<code>UserMapperTests</code>类之前：</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTests {
}
</code></pre>
<p>然后，在类中声明持久层对象的属性：</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTests {
	
	@Autowired
	private UserMapper mapper;

}
</code></pre>
<blockquote>
<p>凡是以前在SSM项目中可以通过<code>getBean()</code>方式获取的对象，在SpringBoot项目中都可以自动装配！</p>
</blockquote>
<p>然后，编写并执行测试方法：</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTests {
	
	@Autowired
	private UserMapper mapper;

	@Test
	public void insert() {
		User user = new User();
		user.setUsername(&quot;springboot&quot;);
		user.setPassword(&quot;1234&quot;);
		Integer rows = mapper.insert(user);
		System.err.println(&quot;rows=&quot; + rows);
	}
	
	@Test
	public void findByUsername() {
		String username = &quot;springboot&quot;;
		User user = mapper.findByUsername(username);
		System.err.println(user);
	}
}
</code></pre>
<h3 id="9-编写控制器处理请求">9. 编写控制器处理请求</h3>
<p>先创建控制器处理请求后的返回结果对象的类型<code>cn.tedu.springboot.sample.util.JsonResult</code>：</p>
<pre><code>public class JsonResult {
	private Integer state;
	private String message;

	// SET/GET ...
}
</code></pre>
<p>SpringBoot项目不需要开发者配置组件扫描，它默认的组件扫描就是项目的根包，即<code>cn.tedu.springboot.sample</code>包，当前项目中所有的组件都必须在这个包或者其子包下！</p>
<p>所以，创建<code>cn.tedu.springboot.sample.controller.UserController</code>控制器类，在类之前添加<code>@RestController</code>注解和<code>@RequestMapping(&quot;user&quot;)</code>注解：</p>
<pre><code>@RestController
@RequestMapping(&quot;user&quot;)
public class UserController {

}
</code></pre>
<blockquote>
<p>使用<code>@RestController</code>相当于<code>@Controller</code>和<code>@ResponseBody</code>的组合使用方式，当使用了<code>@RestController</code>时，该控制器类中所有处理请求的方法都是相当于添加了<code>@ResponseBody</code>注解的！一旦使用了该注解，该控制器类中的方法将不可以转发或者重定向，如果一定要转发或者重定向，必须使用<code>ModelAndView</code>作为处理请求的方法的返回值！</p>
</blockquote>
<p>然后，在控制器类中添加处理请求的方法：</p>
<pre><code>// /user/reg
@RequestMapping(&quot;reg&quot;)
public JsonResult reg(User user) {
}
</code></pre>
<blockquote>
<p>在SpringBoot项目中，默认已经将<code>DispatcherServlet</code>映射的路径配置为<code>/*</code>，即所有请求。</p>
</blockquote>
<p>在处理过程中，显然需要使用到持久层对象来完成数据操作，所以，应该声明持久层对象的属性：</p>
<pre><code>@Autowired
private UserMapper userMapper;
</code></pre>
<p>然后，完成处理请求的细节：</p>
<pre><code>@RequestMapping(&quot;reg&quot;)
public JsonResult reg(User user) {
	// 创建返回值对象
	// 从参数user中获取尝试注册的用户名
	// 根据以上用户名查询用户数据
	// 检查查询结果是否为null
	// 是：用户名未被占用
	// -- 执行注册
	// -- 封装返回值对象的属性：1
	// 否：用户名已经被占用
	// -- 封装返回值对象的属性：2, 错误提示信息
	// 返回
}
</code></pre>
<p>具体实现代码：</p>
<pre><code>@RequestMapping(&quot;reg&quot;)
public JsonResult reg(User user) {
	// 创建返回值对象
	JsonResult jsonResult = new JsonResult();
	// 从参数user中获取尝试注册的用户名
	String username = user.getUsername();
	// 根据以上用户名查询用户数据
	User result = userMapper.findByUsername(username);
	// 检查查询结果是否为null
	if (result == null) {
		// 是：用户名未被占用
		// 执行注册
		userMapper.insert(user);
		// 封装返回值对象的属性：1
		jsonResult.setState(1);
	} else {
		// 否：用户名已经被占用
		// 封装返回值对象的属性：2, 错误提示信息
		jsonResult.setState(2);
		jsonResult.setMessage(&quot;注册失败！尝试注册的用户名(&quot; + username + &quot;)已经被占用！&quot;);
	}
	// 返回
	return jsonResult;
}
</code></pre>
<p>完成后，通过启动类启动项目，打开浏览器，输入<code>http://localhost:8080/user/reg?username=junit&amp;password=1234</code>进行测试。</p>
<p>在对方法添加注解配置映射的路径时，除了<code>@RequestMapping</code>以外，还可以使用<code>@GetMapping</code>、<code>@PostMapping</code>等，它们都是限制了请求方式的！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AJAX]]></title>
        <id>https://guanxuchao.com//post/ajax</id>
        <link href="https://guanxuchao.com//post/ajax">
        </link>
        <updated>2019-07-28T07:45:04.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="1-服务器端如何响应请求">1. 服务器端如何响应请求</h3>
<p>服务器端只响应客户端所需要的数据</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="1-服务器端如何响应请求">1. 服务器端如何响应请求</h3>
<p>服务器端只响应客户端所需要的数据</p>
<!-- more -->
<p>传统的响应方式有转发和重定向，这样的做法有很多问题，比如：转发和重定向都决定了响应的具体页面，不适合多种客户端（浏览器、Android手机、Android平板电脑、iOS手机、iOS平板电脑……）的项目，因为不同的终端设备的性能特征是不一样的，把同样的一个页面都显示给不同的终端设备是极不合适的！正确的做法应该是“服务器端只响应客户端所需要的数据”，至于这些数据如何呈现在终端设备中，由各客户端的开发团队去解决！</p>
<p>如果使用响应正文的方式，还存在“响应数据量小”的优势，则响应速度更快，产生的流量消耗小，用户体验好！</p>
<h3 id="2-服务器端响应正文">2. 服务器端响应正文</h3>
<p>假设客户端会提交<code>http://localhost:8080/AJAX/user/login.do</code>请求，如果需要响应方式是“响应正文”，则需要在处理请求的方法之前补充添加<code>@ResponseBody</code>注解：</p>
<pre><code>@Controller
@RequestMapping(&quot;user&quot;)
public class UserController {
	
	@RequestMapping(&quot;login.do&quot;)
	@ResponseBody
	public String login() {
		return &quot;LOGIN SUCCESS.&quot;;
	}

}
</code></pre>
<p>默认情况下，响应的内容使用了ISO-8859-1编码，所以，不支持中文。</p>
<p>练习：用户在此次提交请求时，<strong>必须</strong>提交用户名和密码作为请求参数，仅当用户名为<code>root</code>且密码为<code>1234</code>时会登录成功(<code>LOGIN SUCCESS.</code>)，否则，响应用户名错误(<code>USERNAME ERROR.</code>)或者密码错误(<code>PASSWORD ERROR.</code>)。</p>
<h3 id="3-服务器响应的正文格式-json格式">3. 服务器响应的正文格式--JSON格式</h3>
<p>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p>
<p>通常，服务器向客户端响应的数据可能不只是1个数据，以登录操作为例，也许可以响应为<code>1</code>表示登录成功，使用<code>2</code>表示登录失败且是因为用户名错误，使用<code>3</code>表示密码错误，则客户端就可以通过对这个值的判断，得知当前操作结果，但是，其它操作可能会需要更多的数据，例如“客户端尝试获取当前登录的用户信息”，需要响应的数据可能包括：用户名、手机号码、电子邮箱、年龄等一系列数据，由于响应结果只是1个字符串，要把这些数据很好的组织起来，才可以方便客户端从这1个字符串中获取其中某部分的数据，否则，如果只是响应为<code>&quot;root13800138001root@163.com26&quot;</code>这样，客户端就无法处理这个响应结果。</p>
<p>早期通常使用XML语法来组织这些数据：</p>
<pre><code>&lt;user&gt;
	&lt;username&gt;root&lt;/username&gt;
	&lt;age&gt;26&lt;/age&gt;
	&lt;phone&gt;13800138001&lt;/phone&gt;
	&lt;email&gt;root@163.com&lt;/email&gt;
&lt;/user&gt;
</code></pre>
<p>使用XML存在的问题：</p>
<ul>
<li>
<p>数据量略大，传输略慢，流量消耗略大，用户体验略差；</p>
</li>
<li>
<p>解析难度大。</p>
</li>
</ul>
<p>目前推荐使用的组织数据的格式是JSON格式，以上数据使用JSON组织后的表现为：</p>
<pre><code>{
	&quot;username&quot;:&quot;root&quot;,
	&quot;age&quot;:26,
	&quot;phone&quot;:&quot;13800138001&quot;,
	&quot;email&quot;:&quot;root@163.com&quot;,
	&quot;skill&quot;:[&quot;Java&quot;, &quot;Java OOP&quot;, &quot;Java SE&quot;, &quot;Java WEB&quot;, &quot;MySQL&quot;, &quot;Spring&quot;],
	&quot;department&quot;:{
		&quot;id&quot;:1,
		&quot;name&quot;:&quot;RD&quot;
	}
}
</code></pre>
<p>JSON数据在Javascript中是默认即识别的对象，可以直接得到其中的属性值：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
	var json = {
		&quot;username&quot;:&quot;root&quot;,
		&quot;age&quot;:26,
		&quot;phone&quot;:&quot;13800138001&quot;,
		&quot;email&quot;:&quot;root@163.com&quot;
	};

	console.log(json.username);
	console.log(json.age);
&lt;/script&gt;
</code></pre>
<p>关于JSON数据格式：</p>
<ul>
<li>
<p>使用<code>{}</code>表示对象，整个JSON数据就是1个对象；</p>
</li>
<li>
<p>所有的属性名都是字符串类型的，在JavaScript中，可以使用单引号或者双引号框柱，因为JSON数据可能在多种不同的编程语言中都出现，一般推荐使用双引号，属性值如果是字符串，也需要使用双引号框柱，如果是数值或者布尔值，则可以不用双引号框柱，属性名和属性值使用冒号<code>:</code>分隔，多个属性的配置之间使用逗号<code>,</code>分隔；</p>
</li>
<li>
<p>属性值的类型还可以是数组，使用中括号<code>[]</code>框柱数组的各元素，各元素之间使用逗号<code>,</code>分隔，在JavaScript中处理时，使用例如<code>json.skill</code>就可以获取到整个数组，使用<code>json.skill.length</code>就可以获取数组的长度，使用<code>json.skill[0]</code>就可以获取数组中下标为0的元素，也可以使用循环语法进行循环；</p>
</li>
<li>
<p>属性值的类型还可以是另一个对象，使用<code>{}</code>表示对象。</p>
</li>
</ul>
<p>如果在JavaScript中，得到是一个使用JSON语法组织的字符串，而不是JSON对象，可以调用<code>JSON.parse(str)</code>函数，将字符串转换为JSON对象。</p>
<h3 id="4-服务器端实现响应json格式的数据">4. 服务器端实现响应JSON格式的数据</h3>
<p>如果需要服务端响应JSON格式的数据，不可能自行拼接出JSON格式的字符串，可以通过工具来解决，首先，需要添加<code>jackson-databind</code>的依赖：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
	&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
	&lt;version&gt;2.9.8&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后，在项目中自定义<code>cn.tedu.ajax.JsonResult</code>响应结果类型：</p>
<pre><code>public class JsonResult {
	
	private Integer state;
	private String message;

	public Integer getState() {
		return state;
	}

	public void setState(Integer state) {
		this.state = state;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

}
</code></pre>
<p>并修改处理请求的方法，返回值类型使用以上自定义的类型：</p>
<pre><code>@RequestMapping(&quot;login.do&quot;)
@ResponseBody
public JsonResult login(
	@RequestParam(&quot;username&quot;) String username,
	@RequestParam(&quot;password&quot;) String password) {
	Integer state;
	String message = null;
	
	if (&quot;root&quot;.equals(username)) {
		if (&quot;1234&quot;.equals(password)) {
			state = 1;
		} else {
			state = 3;
			message = &quot;密码错误！&quot;;
		}
	} else {
		state = 2;
		message = &quot;用户名不存在！&quot;;
	}
	
	JsonResult jsonResult = new JsonResult();
	jsonResult.setState(state);
	jsonResult.setMessage(message);
	return jsonResult;
}
</code></pre>
<p>如果直接运行，会提示406错误：</p>
<pre><code>HTTP Status 406 – Not Acceptable
</code></pre>
<p>需要在spring.xml中添加配置：</p>
<pre><code>&lt;!-- 注解驱动 --&gt;
&lt;mvc:annotation-driven /&gt;
</code></pre>
<p>然后，控制器中处理请求的方法响应的正文就是JSON格式的字符串了。</p>
<p>在控制器中响应正文时，需要添加<code>@ResponseBody</code>注解，SpringMVC框架内置了一系列的转换器(Converter)，用于将方法的返回值转换为响应的正文，在这一系列的转换器中，SpringMVC设计了对应关系和优先级，例如，当方法的返回值类型是<code>String</code>时，就会自动调用<code>StringHttpMessageConverter</code>，当项目中添加了<code>jackson-databind</code>依赖时，如果方法的返回值类型是SpringMVC默认不识别的，就会自动使用<code>Jackson</code>依赖中的转换器！<code>Jackson</code>依赖还会将响应头(Response Headers)中的<code>Content-Type</code>设置为<code>application/json, charset=utf-8</code>。</p>
<p><strong>小结：需要自定义数据类型，以决定响应的JSON数据格式(有哪些属性，分别是什么类型)，然后用自定义类型作为方法的返回值，并处理完成后返回该类型的对象，<code>Jackson</code>依赖就会自动的设置为支持中文，且把响应的对象转换成JSON字符串。</strong></p>
<h3 id="5-ajax">5. AJAX</h3>
<p>AJAX = Asynchronous JavaScript and XML（异步的JavaScript和XML）。</p>
<p>AJAX不是新的编程语言，而是一种使用现有标准的新方法。</p>
<p>AJAX是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>
<p>在实际实现时，通常是基于jQuery框架实现AJAX访问，主要是因为原生技术的代码比较繁琐，且存在浏览器的兼容性问题，在jQuery中，定义了<code>$.ajax()</code>函数，用于处理AJAX请求，调用该函数即可实现异步访问：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(&quot;#btn-login&quot;).click(function(){
	// $.ajax()函数的参数是1个JSON对象
	// url：请求提交到哪里
	// data：需要提交的请求参数
	// type：请求类型
	// dataType：服务器端响应的数据类型，可以是text/xml/json，取值取决于Response Headers中的Content-Type
	// success：服务器端HTTP响应码是2xx时的回调(callback)函数，函数的参数就是服务器端响应的正文结果
	$.ajax({
		&quot;url&quot;:&quot;user/login.do&quot;,
		&quot;data&quot;:$(&quot;#form-login&quot;).serialize(),
		&quot;type&quot;:&quot;post&quot;,
		&quot;dataType&quot;:&quot;json&quot;,
		&quot;success&quot;:function(result) {
			if (result.state == 1) {
				alert(&quot;登录成功！&quot;);
			} else {
				alert(result.message);
			}
		}
	});
});
&lt;/script&gt;</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis-2]]></title>
        <id>https://guanxuchao.com//post/mybatis-2</id>
        <link href="https://guanxuchao.com//post/mybatis-2">
        </link>
        <updated>2019-07-27T07:44:31.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="1-使用mybatis实现简单的查询">1. 使用MyBatis实现简单的查询</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="1-使用mybatis实现简单的查询">1. 使用MyBatis实现简单的查询</h3>
<!-- more -->
<p>在设计查询的抽象方法时：</p>
<ol>
<li>
<p>返回值类型使用所期望的类型；</p>
</li>
<li>
<p>其它部分的设计与增/删/改相同；</p>
</li>
<li>
<p>如果查询的是某1条数据记录，如果有匹配的数据，则返回正确的查询结果，如果没有匹配的数据，将返回<code>null</code>。</p>
</li>
</ol>
<p>例如：根据用户id查询用户数据详情时：</p>
<pre><code>User findById(Integer id);
</code></pre>
<p>在配置该方法的XML映射时，使用的<code>&lt;select&gt;</code>节点必须配置<code>resultType</code>或者<code>resultMap</code>属性中的某一个：</p>
<pre><code>&lt;select id=&quot;findById&quot;
	resultType=&quot;cn.tedu.mybatis.User&quot;&gt;
	SELECT * FROM t_user WHERE id=#{id}
&lt;/select&gt;
</code></pre>
<p>例如：获取当前数据表用户数据的数量：</p>
<pre><code>Integer count();
</code></pre>
<p>映射配置为：</p>
<pre><code>&lt;select id=&quot;count&quot;
	resultType=&quot;java.lang.Integer&quot;&gt;
	SELECT COUNT(*) FROM t_user
&lt;/select&gt;
</code></pre>
<p>例如：查询所有用户数据时：</p>
<pre><code>List&lt;User&gt; findAll();
</code></pre>
<p>配置的映射：</p>
<pre><code>&lt;select id=&quot;findAll&quot;
	resultType=&quot;cn.tedu.mybatis.User&quot;&gt;
	SELECT * FROM t_user ORDER BY id ASC
&lt;/select&gt;
</code></pre>
<h3 id="2-使用多个参数">2. 使用多个参数</h3>
<p>假设需要实现：将id=?的用户的密码修改为?，则抽象方法：</p>
<pre><code>Integer updatePasswordById(Integer id, String newPassword);
</code></pre>
<p>然后配置xml中的映射：</p>
<pre><code>&lt;update id=&quot;updatePasswordById&quot;&gt;
	UPDATE t_user SET password=#{newPassword} where id=#{id}
&lt;/update&gt;
</code></pre>
<p>如果直接执行以上代码，会报告错误：</p>
<pre><code>org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter 'newPassword' not found. Available parameters are [arg1, arg0, param1, param2]
</code></pre>
<p>根本原因是MyBatis框架只能识别1个参数，无论这个参数是什么，都会直接被使用，而多余的参数是不可识别的！</p>
<p>可以在抽象方法的每一个参数之前添加<code>@Param</code>注解，MyBatis框架在处理时，会将这些参数封装成1个Map，依然能满足“只能识别1个参数”的需求，后续在配置XML映射时，使用的<code>#{}</code>占位符中的名称就必须是注解中配置的名称，表示的是MyBatis自动封装的Map中的Key：</p>
<pre><code>Integer updatePasswordById(
		@Param(&quot;id&quot;) Integer arg0, 
		@Param(&quot;password&quot;) String arg1);
</code></pre>
<p>配置的XML映射：</p>
<pre><code>&lt;update id=&quot;updatePasswordById&quot;&gt;
	UPDATE t_user SET password=#{password} where id=#{id}
&lt;/update&gt;
</code></pre>
<p><strong>小结：如果涉及的抽象方法的参数达到2个甚至更多，则每个参数之前都必须添加<code>@Param</code>注解，并在注解中指定名称，后续配置XML映射时，使用的<code>#{}</code>中的名称也是注解中配置的名称！</strong></p>
<p>练习：同时根据用户名和密码查询用户数据！</p>
<h3 id="3-动态sql-foreach">3. 动态SQL-foreach</h3>
<p>MyBatis中的动态SQL指的是根据参数不同，动态的生成不同的SQL语句。</p>
<p>例如：根据若干个id删除用户数据，设计的抽象方法：</p>
<pre><code>Integer deleteByIds(List&lt;Integer&gt; ids);
</code></pre>
<p>然后，在配置映射时：</p>
<pre><code>&lt;delete id=&quot;deleteByIds&quot;&gt;
	DELETE FROM 
		t_user 
	WHERE 
		id 
	IN 
		(
		&lt;foreach collection=&quot;list&quot;
			item=&quot;id&quot; separator=&quot;,&quot;&gt;
			#{id}
		&lt;/foreach&gt;
		)
&lt;/delete&gt;
</code></pre>
<p>在配置<code>&lt;foreach&gt;</code>节点时：</p>
<ul>
<li>
<p><code>collection</code>：被遍历的参数对象，首先，如果对应的抽象方法的参数只有1个时，如果参数是<code>List</code>集合类型的，取值为<code>list</code>，如果参数是数组类型的，取值为<code>array</code>，另外，如果对应的抽象方法的参数有多个，则每个参数肯定都添加了<code>@Param</code>注解，此处需要配置的值就是注解中配置的名称；</p>
</li>
<li>
<p><code>item</code>：遍历过程中获取到的数据的名称，相当于增强for循环的语法中，括号中的第2个部分，在<code>&lt;foreach&gt;</code>节点的子级可以使用<code>#{}</code>占位符，占位符中的名称就是<code>item</code>属性的值；</p>
</li>
<li>
<p><code>separator</code>：遍历过程中各元素使用的分隔符；</p>
</li>
<li>
<p><code>open</code>和<code>close</code>：遍历产生的代码的最左侧字符和最右侧字符。</p>
</li>
</ul>
<h3 id="4-动态sql-if">4. 动态SQL-if</h3>
<p>假设存在抽象方法：</p>
<pre><code>List&lt;User&gt; find(String where, String orderBy, Integer offset, Integer count);
</code></pre>
<p>在配置SQL语句时，可以使用if标签进行对参数的判断，从而产生不同的SQL语句的某个部分，例如：</p>
<pre><code>&lt;select id=&quot;xx&quot; resultType=&quot;xx.xx.xx.User&quot;&gt;
	SELECT
		*
	FROM
		t_user
	&lt;if test=&quot;where != null&quot;&gt;
	WHERE
		#{where}
	&lt;/if&gt;
	&lt;if test=&quot;orderBy != null&quot;&gt;
	ORDER BY
		#{orderBy}
	&lt;/if&gt;
	&lt;if test=&quot;offset != null&quot;&gt;
	LIMIT
		#{offset}, #{count}
	&lt;/if&gt;
&lt;/select&gt;
</code></pre>
<p>以上配置是错误的，并不能所有位置都使用<code>#{}</code>占位符，有几处需要使用<code>${}</code>格式的占位符：</p>
<pre><code>&lt;select id=&quot;find&quot; 
	resultType=&quot;cn.tedu.mybatis.User&quot;&gt;
	SELECT
		*
	FROM
		t_user
	&lt;if test=&quot;where != null&quot;&gt;
	WHERE
		${where}
	&lt;/if&gt;
	&lt;if test=&quot;orderBy != null&quot;&gt;
	ORDER BY
		${orderBy}
	&lt;/if&gt;
	&lt;if test=&quot;offset != null&quot;&gt;
	LIMIT
		#{offset}, #{count}
	&lt;/if&gt;
&lt;/select&gt;
</code></pre>
<h3 id="5-mybatis中的占位符">5. MyBatis中的占位符</h3>
<p>在MyBatis中，编写XML中的SQL语句时，可以使用<code>#{}</code>格式的占位符，还可以使用<code>${}</code>格式的占位符！</p>
<p>MyBatis在处理有占位符的SQL时，如果是<code>${}</code>格式的占位符，会先通过字符串拼接的方式把变量值替换并拼接出SQL语句，然后尝试编译该SQL语句，如果是<code>#{}</code>格式的占位符，会使用<code>?</code>进行占位并尝试编译，编译过后再使用值进行替换。</p>
<p>小结：以前在使用JDBC时，可以使用<code>?</code>表示的部分，都应该使用<code>#{}</code>，也可以理解为只有“值”才可以使用<code>#{}</code>，这种做法是预编译的，否则，如果要对SQL语句中的某个子句或者其他语句的某个部分，甚至是WHERE子句中的表达式，使用<code>${}</code>，这种做法并不会预编译。</p>
<h3 id="6-当字段名与属性名不完全相同时的查询">6. 当字段名与属性名不完全相同时的查询</h3>
<p>修改<code>t_user</code>表结构，添加名为<code>is_delete</code>的字段：</p>
<pre><code>alter table t_user add column is_delete int;

update t_user set is_delete=0;
</code></pre>
<p>然后，对应的<code>User</code>类中也需要添加对应的属性，在Java中，不推荐在变量名中使用<code>_</code>符号，所以，添加的属性应该是：</p>
<pre><code>private Integer isDelete;
</code></pre>
<p>由于名称不是完全相同了，所以，此前的查询功能就无法查询出数据的<code>is_delete</code>字段的值！</p>
<p>MyBatis封装查询结果的标准就是“将查询到的数据封装到与列名完全相同的属性中”，所以，如果字段名与属性名不一致，就会导致默认的列名与属性名不一致，可以在查询时，为列名自定义别名，以保持名称一致，所以，解决方案可以是：</p>
<pre><code>SELECT 
	id, username,
	password, age,
	phone, email,
	is_delete AS isDelete
FROM 
	t_user 
ORDER BY 
	id ASC
</code></pre>
<p>如果在查询时，使用<code>*</code>表示要查询的字段列表，MyBatis就无法自动封装那些名称不一致的数据，可以在XML文件配置<code>&lt;resultMap&gt;</code>节点，并且在查询的<code>&lt;select&gt;</code>节点中，使用<code>resultMap</code>属性取代<code>resultType</code>属性：</p>
<pre><code>&lt;!-- resultMap节点：指导MyBatis如何封装查询结果 --&gt;
&lt;!-- id：自定义名称 --&gt;
&lt;!-- column：查询结果中的列名 --&gt;
&lt;!-- property：type对应的类中的属性名 --&gt;
&lt;resultMap id=&quot;UserEntityMap&quot;
	 type=&quot;cn.tedu.mybatis.User&quot;&gt;
	&lt;result column=&quot;id&quot; property=&quot;id&quot; /&gt;
	&lt;result column=&quot;username&quot; property=&quot;username&quot; /&gt;
	&lt;result column=&quot;password&quot; property=&quot;password&quot; /&gt;
	&lt;result column=&quot;age&quot; property=&quot;age&quot; /&gt;
	&lt;result column=&quot;phone&quot; property=&quot;phone&quot; /&gt;
	&lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;
	&lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot; /&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;findAll&quot;
	resultMap=&quot;UserEntityMap&quot;&gt;
	SELECT 
		*
	FROM 
		t_user 
	ORDER BY 
		id ASC
&lt;/select&gt;
</code></pre>
<p><strong>小结：无论是取别名，还是配置<code>&lt;resultMap&gt;</code>，只要能保证MyBatis知道如何封装名称不一致的数据，就可以正确查询到所需要的结果！如果查询时不用<code>*</code>表示字段列表，且名称不一致的字段较少，则可以优先考虑使用别名，如果使用<code>*</code>查询，或者名称不一致的字段较多，则应该优先考虑配置<code>&lt;resultMap&gt;</code>。</strong></p>
<h3 id="7-关联表查询">7. 关联表查询</h3>
<p>创建<code>t_department</code>部门信息表，要求表中存在<code>id</code>和<code>name</code>这2个字段，向表中插入不少于3条数据：</p>
<pre><code>CREATE TABLE t_department (
	id INT AUTO_INCREMENT COMMENT '部门id',
	name VARCHAR(50) NOT NULL UNIQUE COMMENT '部门名称',
	PRIMARY KEY (id)
) DEFAULT CHARSET=UTF8;

INSERT INTO t_department (name) VALUES ('软件研发部'), ('人力资源部'), ('财务部');
</code></pre>
<p>在<code>t_user</code>表中添加<code>department_id</code>字段，为每一个用户数据分配部门id：</p>
<pre><code>ALTER TABLE t_user ADD COLUMN department_id INT;

UPDATE t_user SET department_id=1 WHERE id IN (2,10,17);
UPDATE t_user SET department_id=2 WHERE id IN (16,14,12);
UPDATE t_user SET department_id=3 WHERE id IN (4,13);
</code></pre>
<p>假设存在需求：根据id查询某用户详情，要求直接显示用户所在部门的名称。</p>
<p>首先，直接查询<code>t_user</code>表是不足以得到完整答案的，为了保证数据表管理的规范，在<code>t_user</code>表中只会存储部门的<code>id</code>，并不会存储部门的<code>name</code>，所以，需要实现该需求，就必须使用关联查询：</p>
<pre><code>SELECT 
	t_user.id, username,
	phone, email,
	password, age,
	is_delete AS isDelete,
	department_id AS departmentId,
	name AS departmentName
FROM 
	t_user 
LEFT JOIN
	t_department 
ON 
	department_id=t_department.id
WHERE
	t_user.id=?
</code></pre>
<p>这样的查询可以符合当前需求，但是，在设计代码时，却没有任何一个实体类可以封装以上查询结果！因为实体类都是与数据表一一相对应的，所以就需要另外创建VO(Value Object)类，VO类的设计原则是根据查询结果来确定各属性的：</p>
<pre><code>public class UserVO {
	private Integer id;
	private String username;
	private String password;
	private Integer age;
	private String phone;
	private String email;
	private Integer isDelete;
	private Integer departmentId;
	private String departmentName;
	// SET/GET/hashCode/equals/toString/Serializable
}
</code></pre>
<p>其实，VO类与实体类的设计方式是几乎一样的，只是定位不同，实体类与数据表对应，VO类与查询结果对应。</p>
<p>设计的抽象方法的返回值就应该是<code>UserVO</code>：</p>
<pre><code>UserVO findUserVOById(Integer id);
</code></pre>
<p>然后，配置映射时，需要注意自定义别名，或者配置<code>&lt;resultMap&gt;</code>，同时，注意：如果某个字段名在2张或者涉及的多张表中都存在，必须明确的指定表名，例如这2张表中都有<code>id</code>字段，每次涉及该字段都必须在左侧指定表名：</p>
<pre><code>&lt;select id=&quot;findUserVOById&quot;
	resultType=&quot;cn.tedu.mybatis.UserVO&quot;&gt;
	SELECT 
		t_user.id, username,
		phone, email,
		password, age,
		is_delete AS isDelete,
		department_id AS departmentId,
		name AS departmentName
	FROM 
		t_user 
	LEFT JOIN
		t_department 
	ON 
		department_id=t_department.id
	WHERE
		t_user.id=#{id}
&lt;/select&gt;

查询某个部门的信息，同时，获取该部门中所有用户的信息。
</code></pre>
<p>执行该操作的SQL语句大致是：</p>
<pre><code>SELECT 
	*
FROM
	t_department
LEFT JOIN
	t_user
ON
	t_department.id=t_user.department_id
WHERE
	t_department.id=?
</code></pre>
<p>执行以上查询，可能产生多条结果，因为某1个部门中可能有多个用户！但是，实际需求是“查询某个部门的信息”，结果应该只有1个数据！</p>
<p>为了合理的表示查询结果，可以定义部门信息的VO类<code>cn.tedu.mybatis.DepartmentVO</code>，该类的设计：</p>
<pre><code>public class DepartmentVO {
	private Integer id; // 部门id
	private String name; // 部门名称
	private List&lt;User&gt; users; // 部门中的用户
}
</code></pre>
<p>在开发持久层功能时，由于操作的数据主体不再是“用户”数据，则以前的<code>UserMapper</code>接口就不再适用，应该先创建新的<code>cn.tedu.mybatis.DepartmentMapper</code>持久层接口，并在接口中定义“根据部门id查询部门详情”的抽象方法：</p>
<pre><code>public interface DepartmentMapper {
	
	DepartmentVO findVOById(Integer id);

}
</code></pre>
<p>与添加新的接口的原因相同，也应该给出新的XML文件配置以上抽象方法的SQL语句，所以，可以把原有的<code>UserMapper.xml</code>复制并粘贴，然后重命名为<code>DepartmentMapper.xml</code>，删除原有的配置，再配置以上抽象方法的SQL语句：</p>
<pre><code>&lt;select id=&quot;findVOById&quot; resultType=&quot;xx.xx.xx.DepartmentVO&quot;&gt;
	SELECT 
		t_department.id, name,
		t_user.id, username,
		password, age,
		phone, email,
		is_delete AS isDelete,
		department_id AS departmentId
	FROM
		t_department
	LEFT JOIN
		t_user
	ON
		t_department.id=t_user.department_id
	WHERE
		t_department.id=#{id}
&lt;/select&gt;
</code></pre>
<p>在以上查询结果中，会出现2个名为<code>id</code>的列名，后续在处理数据时，MyBatis将无法正确的区分所需要的<code>id</code>值是哪一列的数据，所以，在查询时，至少需要为以上2个<code>id</code>字段中的1个定义别名，或者将2个都定义不同的别名，保证查询结果中的列名都是唯一的，不会出现冲突：</p>
<pre><code>SELECT 
		t_department.id AS did, name,
		t_user.id AS uid ... ...
</code></pre>
<p>在配置<code>&lt;resultMap&gt;</code>时，关于唯一字段的配置，应该使用<code>&lt;id /&gt;</code>节点进行配置，而不应该使用<code>&lt;result /&gt;</code>节点来配置，2个节点的配置方式完全相同，即使不使用<code>&lt;id /&gt;</code>而使用<code>&lt;result /&gt;</code>也能实现功能，但是，MyBatis是天生自带缓存的，使用<code>&lt;id /&gt;</code>节点配置的数据会作为缓存数据的标识，而使用<code>&lt;result /&gt;</code>节点的配置则不会。</p>
<p>在配置1对多关系时，需要使用<code>&lt;collection&gt;</code>节点，例如1个部门有多个用户，在数据方面，1个部门的VO对象中有1个<code>List</code>集合存储多个<code>User</code>数据。</p>
<p>完整的<code>&lt;resultMap&gt;</code>配置应该是：</p>
<pre><code>&lt;resultMap id=&quot;DepartmentVOMap&quot;
	type=&quot;cn.tedu.mybatis.DepartmentVO&quot;&gt;
	&lt;id column=&quot;did&quot; property=&quot;id&quot;/&gt;
	&lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
	&lt;!-- collection节点：用于配置集合类型的属性 --&gt;
	&lt;!-- property：依然表示类的属性 --&gt;
	&lt;!-- ofType：集合里面放的是什么类型的数据 --&gt;
	&lt;collection property=&quot;users&quot;
		ofType=&quot;cn.tedu.mybatis.User&quot;&gt;
		&lt;!-- column：依然是查询结果中的列名 --&gt;
		&lt;!-- property：ofType的类型中的属性名 --&gt;
		&lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt;
		&lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
		&lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt;
		&lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt;
		&lt;result column=&quot;phone&quot; property=&quot;phone&quot;/&gt;
		&lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt;
		&lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot;/&gt;
		&lt;result column=&quot;department_id&quot; property=&quot;departmentId&quot;/&gt;
	&lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre>
<p>查询节点的配置为：</p>
<pre><code>&lt;select id=&quot;findVOById&quot;
	resultMap=&quot;DepartmentVOMap&quot;&gt;
	SELECT 
		t_department.id AS did, name,
		t_user.id AS uid, username,
		password, age,
		phone, email,
		is_delete, department_id
	FROM
		t_department
	LEFT JOIN
		t_user
	ON
		t_department.id=t_user.department_id
	WHERE
		t_department.id=#{id}
&lt;/select&gt;
</code></pre>
<p>注意：在使用了<code>&lt;resultMap&gt;</code>的查询中，并不需要因为查询结果的列名与类的属性名不同而定义别名，例如以上的<code>is_delete</code>和<code>department_id</code>就没有再定义别名，而只需要为名字冲突的定义别名，例如以上的用户表的id和部门表的id。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis-1]]></title>
        <id>https://guanxuchao.com//post/mybatis-1</id>
        <link href="https://guanxuchao.com//post/mybatis-1">
        </link>
        <updated>2019-07-26T07:42:02.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="21-框架的作用">2.1. 框架的作用</h4>
<p>简化数据库编程，开发者只要指定每项数据操作时的SQL语句及对应的抽象方法即可。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="21-框架的作用">2.1. 框架的作用</h4>
<p>简化数据库编程，开发者只要指定每项数据操作时的SQL语句及对应的抽象方法即可。</p>
<!-- more -->
<h4 id="22-创建springmybatis的项目">2.2. 创建Spring+MyBatis的项目</h4>
<p>创建Maven Project，Group Id为cn.tedu.mybatis，Artifact Id为MyBatis，Packaing选择war。</p>
<p>创建完成后，生成web.xml，添加依赖，添加Tomcat运行环境，复制web.xml中的配置，复制前序项目中的spring.xml(需要删除拦截器的配置)。</p>
<p>然后，需要添加一些新的依赖，首先，添加mybatis的依赖：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.mybatis&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis&lt;/artifactId&gt;
	&lt;version&gt;3.5.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>MyBatis框架是可以独立使用的，但是配置相对繁琐，且没有实际价值，通常都是与Spring结合使用的，甚至结合了SpringMVC，所以，需要添加<code>mybatis-spring</code>的依赖：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.mybatis&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
	&lt;version&gt;2.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>MyBatis的底层是基于jdbc实现的，所以，结合Spring使用后，需要添加<code>spring-jdbc</code>依赖，该依赖的代码与<code>spring-webmvc</code>几乎一样，只是<code>artifact id</code>不同，通常，这2个依赖的版本应该完全相同：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
	&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
	&lt;version&gt;4.3.8.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>还需要添加<code>mysql-connector-java</code>的依赖：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;mysql&lt;/groupId&gt;
	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
	&lt;version&gt;8.0.16&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>另外，还需要<code>commons-dbcp</code>数据库连接池的依赖：</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
	&lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
	&lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>最后，检查是否已经添加好了<code>junit</code>依赖，如果已经存在，则跳过，如果没有添加，则补充。</p>
<h4 id="23-配置数据库连接">2.3. 配置数据库连接</h4>
<p>在<strong>src/main/resources</strong>下创建<strong>db.properties</strong>文件，以确定数据库连接的相关配置：</p>
<pre><code>url=jdbc:mysql://localhost:3306/tedu_ums?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai
driver=com.mysql.cj.jdbc.Driver
username=root
password=root
initialSize=2
maxActive=5
</code></pre>
<p>然后，需要在Spring的配置文件中读取以上配置信息：</p>
<pre><code>&lt;!-- 读取db.properties --&gt;
&lt;util:properties id=&quot;dbConfig&quot;
	location=&quot;classpath:db.properties&quot; /&gt;
</code></pre>
<p>最终，程序运行时，需要使用的数据源是<code>BasicDataSource</code>，框架会通过这个类的对象获取数据库连接对象，然后实现数据访问，所以，就需要为这个类的相关属性注入值，把数据库配置信息确定下来：</p>
<pre><code>&lt;!-- 配置数据源 --&gt;
&lt;bean id=&quot;dataSource&quot;
	class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
	&lt;property name=&quot;url&quot; 
		value=&quot;#{dbConfig.url}&quot; /&gt;
	&lt;property name=&quot;driverClassName&quot; 
		value=&quot;#{dbConfig.driver}&quot; /&gt;
	&lt;property name=&quot;username&quot; 
		value=&quot;#{dbConfig.username}&quot; /&gt;
	&lt;property name=&quot;password&quot; 
		value=&quot;#{dbConfig.password}&quot; /&gt;
	&lt;property name=&quot;initialSize&quot; 
		value=&quot;#{dbConfig.initialSize}&quot; /&gt;
	&lt;property name=&quot;maxActive&quot; 
		value=&quot;#{dbConfig.maxActive}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>接下来，可以检验一下以上完成的配置是否正确，则在<strong>src/test/java</strong>下创建<code>cn.tedu.mybatis.Tests</code>测试类，编写并执行测试方法：</p>
<pre><code>@Test
public void getConnection() throws SQLException {
	ClassPathXmlApplicationContext ac
		= new ClassPathXmlApplicationContext(
			&quot;spring.xml&quot;);
	
	BasicDataSource ds = ac.getBean(&quot;dataSource&quot;, BasicDataSource.class);
	
	Connection conn = ds.getConnection();
	System.out.println(conn);
	
	ac.close();
}
</code></pre>
<h4 id="24-设计接口和抽象方法">2.4. 设计接口和抽象方法</h4>
<p>创建<code>cn.tedu.mybatis.User</code>类，类的属性与<code>t_user</code>表保持一致：</p>
<pre><code>public class User {

	private Integer id;
	private String username;
	private String password;
	private Integer age;
	private String phone;
	private String email;

	// SET/GET/toString/hashCode/equals/Serializable

}
</code></pre>
<p>在MyBatis中，要求抽象方法写在接口中，所以，需要先创建<code>cn.tedu.mybatis.UserMapper</code>接口：</p>
<pre><code>public interface UserMapper {
}
</code></pre>
<p>然后，在接口中添加抽象方法，设计原则：</p>
<ul>
<li>
<p>如果要执行的操作是<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>，返回值类型使用<code>Integer</code>，表示受影响的行数；</p>
</li>
<li>
<p>方法的名称可以自定义，但是，不允许重载；</p>
</li>
<li>
<p>参数列表根据执行SQL语句时的不确定数据来设计。</p>
</li>
</ul>
<p>对于要执行的数据操作，先完成“增加”操作，则添加关于“增加”用户数据的抽象方法：</p>
<pre><code>Integer insert(User user);
</code></pre>
<p>然后，需要通过配置，让MyBatis框架知道接口在哪里，所以，在Spring的配置文件中添加配置：</p>
<pre><code>&lt;!-- 配置MapperScannerConfigurer --&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
	&lt;!-- 指定MyBatis所需的接口在哪里 --&gt;
	&lt;property name=&quot;basePackage&quot;
		value=&quot;cn.tedu.mybatis&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="25-配置sql语句">2.5. 配置SQL语句</h4>
<p>下载<code>http://doc.canglaoshi.org/config/mybatis-mapper.zip</code>文件，得到压缩包，在项目的<strong>src/main/resources</strong>下创建名为<strong>mappers</strong>的文件夹，解压下载的压缩包，将得到的xml文件复制到<strong>mappers</strong>文件夹中，并重命名为<strong>UserMapper.xml</strong>。</p>
<p>然后在该文件中配置SQL语句：</p>
<pre><code>&lt;!-- namespace：当前XML文件用于配置哪个接口中抽象方法对应的SQL语句 --&gt;
&lt;mapper namespace=&quot;cn.tedu.mybatis.UserMapper&quot;&gt;

	&lt;!-- 使用insert节点配置插入数据的SQL语句 --&gt;
	&lt;!-- id：抽象方法的方法名 --&gt;
	&lt;!-- 在#{}中间的是方法的参数User类中的属性名称 --&gt;
	&lt;insert id=&quot;insert&quot;&gt;
		INSERT INTO t_user (
			username, password,
			age, phone,
			email
		) VALUES (
			#{username}, #{password},
			#{age}, #{phone},
			#{email}
		)
	&lt;/insert&gt;
	
&lt;/mapper&gt;
</code></pre>
<p>最后，还是需要补充配置，使得MyBatis框架知道这些XML文件在哪里，且执行时使用的数据源是哪一个，则在Spring的配置文件中补充配置：</p>
<pre><code>&lt;!-- SqlSessionFactoryBean --&gt;
&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
	&lt;!-- XML文件在哪里 --&gt;
	&lt;property name=&quot;mapperLocations&quot;
		value=&quot;classpath:mappers/*.xml&quot; /&gt;
	&lt;!-- 使用哪个数据源 --&gt;
	&lt;property name=&quot;dataSource&quot;
		ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>完成之后，在<code>Tests</code>中编写并执行单元测试：</p>
<pre><code>@Test
public void insert() {
	ClassPathXmlApplicationContext ac
		= new ClassPathXmlApplicationContext(
			&quot;spring.xml&quot;);
	
	UserMapper userMapper
		= ac.getBean(&quot;userMapper&quot;, UserMapper.class);
	System.out.println(userMapper.getClass());
	
	User user = new User();
	user.setUsername(&quot;admin&quot;);
	user.setPassword(&quot;1234&quot;);
	Integer rows = userMapper.insert(user);
	System.out.println(&quot;rows=&quot; + rows);
	
	ac.close();
}
</code></pre>
<h4 id="26-实时获取新插入的数据的id">2.6. 实时获取新插入的数据的id</h4>
<p>在配置<code>&lt;insert&gt;</code>节点时，添加<code>useGeneratedKeys=&quot;true&quot;</code>和<code>keyProperty=&quot;id&quot;</code>的配置：</p>
<pre><code>&lt;insert id=&quot;insert&quot;
	useGeneratedKeys=&quot;true&quot;
	keyProperty=&quot;id&quot;&gt;
</code></pre>
<p>然后，执行数据操作后，方法的参数对象中就会被封装自动编号的id值！</p>
<p>以上配置的2个属性，<code>useGeneratedKeys</code>表示“要不要获取自动生成的字段的值，即自动编号的值”，<code>keyProperty</code>表示“获取到的自动编号的值封装在参数对象的哪个属性中”，所以，在本例中，指的是<code>User</code>类中的<code>id</code>属性，并不是<code>t_user</code>表中的<code>id</code>字段。</p>
<blockquote>
<p>通常，Property单词表示“属性”，类才有属性，数据表没有属性，Field表示“字段”，仅当描述数据表结构时才称之为字段，Column表示“列”，仅当描述查询结果时才称之为列。</p>
</blockquote>
<h3 id="-">----------------------------------</h3>
<h3 id="附1如果快速的向数据表中插入已知的1000万条数据">附1：如果快速的向数据表中插入已知的1000万条数据</h3>
<p>假设这1000万条数据在1个<code>List</code>集合中，将这个集合进行遍历，循环1000万次，结合数据库编程技术，就可以将这些数据插入到数据库中。</p>
<p>这样做的缺陷：</p>
<ol>
<li>
<p>在实际工作环境中，应用服务器(程序运行所在的Tomcat服务器)与MySQL数据库服务器并不是同一台服务器，当需要执行数据操作时，会由应用服务器将SQL语句发送到MySQL数据库服务器，发送过程中就需要建立网络连接，才可以发送SQL语句，如果使用以上原始做法，就需要连接1000万次，每次发送1条SQL语句，效率非常低下！</p>
</li>
<li>
<p>每次执行1条SQL语句之前，MySQL服务器还会对SQL语句进行词法分析、语义分析、编译等过程，才可以执行，假设有1000万条SQL语句，则这些词法分析、语义分析、编译等过程就需要经历1000万次！</p>
</li>
</ol>
<p>针对问题1，可以使用批处理来解决，批处理可以一次性发送多条SQL语句到数据库服务器，减少传递SQL语句的次数，从而提高运行效率；</p>
<p>针对问题2，可以把<code>INSERT INTO xx () VALUES ();</code>这种语法调整为<code>INSERT INTO xx () VALUES (值列表1), (值列表2), ..., (值列表N)</code>，这种做法可以使得1条SQL语句插入多条数据，假设每条SQL语句插入了1000条数据，则只需要1万条SQL语句即可！</p>
<p>所以，总的来说，可以使用每条SQL语句插入100条数据，批处理时每次发送1000条这样的SQL语句，整体循环100次，就可以完成所有数据的插入！</p>
<blockquote>
<p>理论上来说，批处理时，不建议一次性处理超过5000条SQL语句。另外，每条SQL语句也不是插入越多数据就越快，拼接这样的SQL语句也是需要耗时的。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringMVC-3]]></title>
        <id>https://guanxuchao.com//post/springmvc-3</id>
        <link href="https://guanxuchao.com//post/springmvc-3">
        </link>
        <updated>2019-07-21T07:01:44.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="1-使用session">1. 使用Session</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="1-使用session">1. 使用Session</h3>
<!-- more -->
<p>当需要向Session中存入数据时，可以使用<code>ModelMap</code>对象将数据进行封装，操作方式与封装转发的数据完全相同，例如：</p>
<pre><code>modelMap.addAttribute(&quot;username&quot;, username);
</code></pre>
<p>然后，需要在当前控制器类之前添加<code>@SessionAttributes</code>注解，并且，在注解中显式的指定<code>ModelMap</code>中封装的哪些数据是需要存储在Session中的，例如：</p>
<pre><code>@Controller 
@RequestMapping(value=&quot;user&quot;)
@SessionAttributes(&quot;username&quot;)
public class UserController {
	// ...
}
</code></pre>
<p>当添加了以上注解后，如果<code>ModelMap</code>中被存入了名为<code>username</code>的数据，该数据就在Session中，而<code>ModelMap</code>中的其它数据依然只能用于转发，也就是数据的作用域只在Request级别。</p>
<p>关于<code>@SessionAttributes</code>注解，其属性的配置可以参考该注解的源代码：</p>
<pre><code>@AliasFor(&quot;names&quot;)
String[] value() default {};

@AliasFor(&quot;value&quot;)
String[] names() default {};

Class&lt;?&gt;[] types() default {};
</code></pre>
<p>通过以上源代码可以看到：<code>value</code>和<code>names</code>属性的作用是完全相同，用于指定<code>ModelMap</code>中的哪些名称对应的数据需要存放到Session中，可以使用字符串数组表示多个属性，另外，还可以配置<code>types</code>属性用于指定Session的数据的数据类型，也可以是数组类型，与配置的<code>names</code>保持一致即可。</p>
<p>使用这种做法操作Session非常简单，但是，也存在一系列的问题：</p>
<ol>
<li>
<p>默认情况下，重定向时会把Session中的数据暴露在URL中；</p>
</li>
<li>
<p>通过<code>ModelMap</code>存放的数据一定会在Request的作用域中，所以，通过这种方式存放到Session中的数据，其实在Request中也是存在的；</p>
</li>
<li>
<p>通过这种方式存放到Session中的数据，不可以通过Session对象的<code>invalidate()</code>方法清除！只能通过<code>SessionStatus</code>类的<code>setComplete()</code>方法进行清除！</p>
</li>
</ol>
<p>更加简单的操作Session的方式就是直接在处理请求的方法中添加<code>HttpSession</code>类型的参数，然后在方法体中直接操作即可，例如：</p>
<pre><code>@RequestMapping(&quot;handle_login.do&quot;) 
public String handleLogin(String username, String password,
		ModelMap modelMap, HttpSession session) {
	// 日志
	System.out.println(&quot;UserController.handleLogin()&quot;);
	System.out.println(&quot;\tusername=&quot; + username);
	System.out.println(&quot;\tpassword=&quot; + password);
	
	// 判断用户名是否正确
	if (&quot;root&quot;.equals(username)) {
		// 是：判断密码是否正确
		if (&quot;1234&quot;.equals(password)) {
			// 是：登录成功，将用户名存入到Session
			// modelMap.addAttribute(&quot;username&quot;, username);
			session.setAttribute(&quot;username&quot;, username);
			// 重定向到主页
			return &quot;redirect:../index.do&quot;;
		} else {
			// 否：密码错误
			modelMap.addAttribute(&quot;errorMessage&quot;, &quot;ModelMap：密码错误&quot;);
			return &quot;error&quot;;
		}
	} else {
		// 否：用户名错误
		modelMap.addAttribute(&quot;errorMessage&quot;, &quot;ModelMap：用户名错误&quot;);
		return &quot;error&quot;;
	}
}
</code></pre>
<p>使用这种做法并不存在以上使用<code>@SessionAttributes</code>时的各种问题，操作也非常简单，缺点就是不易于执行单元测试！</p>
<p>可以忽略“不易于执行单元测试”，甚至“不使用<code>@SessionAttributes</code>”的原因可能是：可以使用专门的测试工具去测试控制器，所以，在控制器中的方法本身是不需要执行单元测试的，甚至在大型项目中根本就不会使用Session，那各种使用方式都是不需要的！</p>
<h3 id="2-springmvc的拦截器interceptor">2. SpringMVC的拦截器(Interceptor)</h3>
<p>如果项目中有多个请求需要执行相同的数据处理方案，就可以使用拦截器来实现。</p>
<p>拦截器的作用并不一定是要把请求“拦截下来，不允许向后执行”，其主要特征是：若干种不同的请求都需要先执行拦截器中的代码，才可以向后执行。</p>
<p>当然，拦截器也确实具备“拦截”的功能，即：可以将请求拦截下来，不允许向后执行。</p>
<p>假设需要定义一个“登录拦截器”，实现“如果用户已经登录，则放行，如果未登录，则拦截，不允许向后执行”。</p>
<p>首先，需要自定义<code>cn.tedu.spring.LoginInterceptor</code>拦截器类，实现<code>HandlerInterceptor</code>：</p>
<pre><code>public class LoginInterceptor implements HandlerInterceptor {

	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		System.out.println(&quot;LoginInterceptor.preHandle()&quot;);
		return false;
	}

	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			ModelAndView modelAndView) throws Exception {
		System.out.println(&quot;LoginInterceptor.postHandle()&quot;);
	}

	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
			throws Exception {
		System.out.println(&quot;LoginInterceptor.afterCompletion()&quot;);
	}

}
</code></pre>
<p>拦截器需要在Spring的配置文件中进行配置才可以使用：</p>
<pre><code>&lt;!-- 配置拦截器链 --&gt;
&lt;mvc:interceptors&gt;
	&lt;!-- 配置第1个拦截器 --&gt;
	&lt;mvc:interceptor&gt;
		&lt;!-- 拦截的路径 --&gt;
		&lt;mvc:mapping path=&quot;/index.do&quot;/&gt;
		&lt;!-- 拦截器类 --&gt;
		&lt;bean class=&quot;cn.tedu.spring.LoginInterceptor&quot; /&gt;
	&lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<p>如果需要实现“验证登录以决定是否拦截或者放行”的功能，需要重写拦截器类中的<code>preHandle()</code>方法：</p>
<pre><code>public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
		throws Exception {
	System.out.println(&quot;LoginInterceptor.preHandle()&quot;);
	// 获取HttpSession对象
	HttpSession session = request.getSession();
	// 判断Session中有没有登录的数据
	if (session.getAttribute(&quot;username&quot;) == null) {
		// 没有登录数据，即未登录，则重定向到登录页
		// http://localhost:8080/XX/index.do
		// http://localhost:8080/XX/user/password.do
		String projectName = request.getServletContext().getContextPath();
		response.sendRedirect(projectName + &quot;/user/login.do&quot;);
		// 返回false表示拦截，不允许向后执行
		return false;
	}
	// 返回true表示放行，允许向后执行
	return true;
}
</code></pre>
<p>注意：即使调用了<code>response.sendRedirect()</code>进行重定向，如果要阻止继续向后运行，仍然需要<code>return false;</code>。</p>
<p>在配置拦截器时，使用的是<code>&lt;mvc:mapping /&gt;</code>配置需要拦截的路径，每个拦截器都可以配置1~N个该节点。</p>
<p>在配置路径时，还可以使用<code>*</code>作为通配符，例如配置为<code>&lt;mvc:mapping path=&quot;/product/*&quot; /&gt;</code>，则表示例如<code>/product/index.do</code>、<code>/product/add.do</code>、<code>/product/list.do</code>等路径都会被拦截！但是，1个<code>*</code>只能通配1层资源，例如<code>/product/*</code>就不会匹配上<code>/product/x/y.do</code>，如果需要通配若干层路径，可以使用2个<code>*</code>，即配置为<code>/product/**</code>，使用2个<code>*</code>是无视层级的，无论是<code>/product/list.do</code>，还是<code>/product/x/y.do</code>，甚至更多层级的，都可以通配！</p>
<p>另外，还可以添加<code>&lt;mvc:exclude-mapping /&gt;</code>用于配置例外路径，也就是“白名单”，被添加在白名单中的路径将不被拦截器处理，与<code>&lt;mvc:mapping /&gt;</code>的配置方式完全相同，可以有多个配置白名单的节点，在配置时，路径中也可以使用通配符。</p>
<p>在配置整个<code>&lt;mvc:interceptor&gt;</code>节点时，其子级的节点必须先配置<code>&lt;mvc:mapping /&gt;</code>，再配置<code>&lt;mvc:exclude-mapping /&gt;</code>，最后配置<code>&lt;bean&gt;</code>，不可以颠倒顺序！</p>
<h3 id="3-在springmvc中统一处理异常">3. 在SpringMVC中统一处理异常</h3>
<p>在Java中，异常的继承体系是：</p>
<pre><code>Throwable
	Error
		OutOfMemoryError
	Exception
		SQLException
		IOException
			FileNotFoundException
		RuntimeException
			NullPointerException
			ClassCastException
			ArithmeticException
			NumberFormatException
			IndexOutOfBoundsException
				ArrayIndexOutOfBoundsException
				StringIndexOutOfBoundsException
</code></pre>
<p>在Exception中，RuntimeException及其子孙类异常是比较特殊的异常，完全不受Java处理异常的语法约束，因为这些异常可能出现的频率极高，并且，这些异常是可以通过更加严谨的编程来杜绝异常的发生的！</p>
<p>常见的处理异常的做法是捕获(try...catch)或者声明抛出(throw/throws)，在实际处理时，如果当前类适合处理异常，就应该使用try...catch捕获并处理，如果当前类不适合处理异常，则应该声明抛出，然后续调用这个方法的角色进行处理。</p>
<p>在服务器端的项目中，通常适合处理异常的都是控制器，但是，某些异常可能在多个不同的功能中都会出现，在处理不同的请求时采取相同的代码进行处理，就会导致代码冗余，不便于统一管理，所以，在SpringMVC框架中就提供了统一处理异常的机制。</p>
<p>可以在控制器类中添加统一处理异常的方法，关于该方法：</p>
<ol>
<li>
<p>应该使用<code>public</code>权限；</p>
</li>
<li>
<p>返回值的意义与处理请求的方法完全相同；</p>
</li>
<li>
<p>方法名称可以自定义；</p>
</li>
<li>
<p>方法中必须包含异常类型的参数，且参数的类型能包括所有可能需要处理的异常，例如可能处理<code>NullPointerException</code>，则参数的类型可以是<code>NullPointerException</code>或者<code>RuntimeException</code>或者<code>Exception</code>甚至<code>Throwable</code>，如果同时还需要处理<code>NumberFormatException</code>，参数类型就不可以是<code>NullPointerException</code>，简单来说，写<code>Throwable</code>绝对错不了；</p>
</li>
<li>
<p>与处理请求的方法不同，不可以随心所欲的添加参数，如果需要转发数据，只能添加<code>HttpServletRequest</code>参数，不可以使用<code>ModelMap</code>；</p>
</li>
<li>
<p>必须添加<code>@ExceptionHandler</code>注解。</p>
</li>
</ol>
<p>所以，处理请求的方法可以是：</p>
<pre><code>@ExceptionHandler
public String handleException(Throwable ex, HttpServletRequest request) {
	if (ex instanceof NullPointerException) {
		request.setAttribute(&quot;errorMessage&quot;, &quot;空指针异常！&quot;);
	} else if (ex instanceof ArrayIndexOutOfBoundsException) {
		request.setAttribute(&quot;errorMessage&quot;, &quot;数据下标越界异常异常！&quot;);
	} else {
		request.setAttribute(&quot;errorMessage&quot;, &quot;未知异常：&quot; + ex.getClass().getName());
	}
	
	return &quot;error&quot;;
}
</code></pre>
<p>一旦添加了该方法，当前类中任何处理请求的方法都不必处理相关异常，等同于这些方法把异常抛出了，将由以上方法进行统一处理！</p>
<p>需要注意的是：该方法只能处理当前类处理请求时出现的异常，如果其他控制器类的方法抛出了异常，是不会被处理的！可以把该处理异常的方法放在所有控制器类公共的父类中！</p>
<p>关于<code>@ExceptionHandler</code>的源代码：</p>
<pre><code>public @interface ExceptionHandler {

	/**
	 * Exceptions handled by the annotated method. If empty, will default to any
	 * exceptions listed in the method argument list.
	 */
	Class&lt;? extends Throwable&gt;[] value() default {};

}
</code></pre>
<p>该注解可以指定需要被处理的异常的种类！参数可以是数组，即同时指定多种异常都将被该方法进行处理！</p>
<h3 id="4-springmvc框架小结">4. SpringMVC框架小结</h3>
<ol>
<li>
<p>理解SpringMVC执行核心流程；</p>
</li>
<li>
<p>掌握获取请求参数的方式；</p>
</li>
<li>
<p>理解转发与重定向；</p>
</li>
<li>
<p>了解转发时如何转发数据；</p>
</li>
<li>
<p>掌握@RequestMapping、@RequestParam注解的使用；</p>
</li>
<li>
<p>掌握拦截器的使用；</p>
</li>
<li>
<p>掌握处理异常的使用。</p>
</li>
</ol>
<h3 id="-">---------------------------</h3>
<h3 id="附1什么时候需要使用session">附1：什么时候需要使用Session</h3>
<p>由于Http协议是无状态协议，每次请求与响应结束后，服务器与客户端就会断开，期间产生的数据及使用数据创建的状态都不会被保留下来，导致下次再次访问时，不可以使用前序产生的数据和状态，为了解决这个问题，就产生了Cookie和Session的用法，其中，Cookie是把特定的数据存储在客户端，而Session是把特定的信息存储在服务器端的内存中。</p>
<p>通常，使用Session存储：</p>
<ol>
<li>
<p>用户的身份的唯一标识，例如：用户的id；</p>
</li>
<li>
<p>使用频率较高的数据，例如：用户名；</p>
</li>
<li>
<p>不便于使用其它解决方案去存储或者传递的数据。</p>
</li>
</ol>
<h3 id="附2-拦截器interceptor和过滤器filter的区别">附2. 拦截器(Interceptor)和过滤器(Filter)的区别</h3>
<p>拦截器和过滤器都是可以设置在若干种不同的请求处理之前的，都可以实现“拦截”和“放行”的做法，项目中，都可以存在若干个拦截器或者过滤器形成拦截器链或者过滤器链。</p>
<p>过滤器是JavaEE中的组件，拦截器是SpringMVC中的组件，只要是使用Java语言做服务器端开发都可以使用过滤器，但是，只有使用了SpringMVC框架才可以使用拦截器，并且，如果使用SpringMVC时，<code>DispatcherServlet</code>映射的路径是<code>*.do</code>，则只有以<code>.do</code>为后缀的请求才可能被拦截器处理，也就是说，只有被<code>DispatcherServlet</code>映射到的路径才可能被拦截器处理。</p>
<p>过滤器是执行在所有<code>Servlet</code>组件之前的，而拦截器是执行在<code>DispatcherServlet</code>之后、且在各Controller控制器之前及之后的组件！</p>
<p>过滤器是需要在<strong>web.xml</strong>中进行配置的，其过滤的路径只能通过<code>&lt;url-pattern&gt;</code>节点配置1个路径，配置非常不灵活，拦截器可以通过若干个<code>&lt;mvc:mapping /&gt;</code>节点配置若干个黑名单，还可以通过若干个<code>&lt;mvc:exclude-mapping /&gt;</code>节点配置若干个白名单，配置就非常灵活！</p>
<p>虽然拦截器和过滤器可以实现的的功能几乎相同，且拦截器的配置更加灵活，但是，由于执行时间节点的差异，拦截器也并不能完全取代过滤器！</p>
<h3 id="附3-解决乱码问题">附3. 解决乱码问题</h3>
<p>计算机能够直接识别并处理的都是二进制数，也就是由0和1组成的序列，每个存储0或者1的空间称为“位(bit)”，由于每个二进制位只能存储1个0或者1个1，只能表达2种可能性，就不足以表示更多的内容，在计算机中，使用了更大的单位“字节(byte)”作为基本单位，每个字节由8个二进制位组成。</p>
<p>在ASCII编码表中指定了人类生活使用的字符与二进制数的对应关系，例如<code>a</code>对应的就是<code>110 0001</code>，假设输入了1个<code>a</code>，其实计算机处理的是<code>110 0001</code>，当计算机运算得到<code>110 0001</code>，就会显示为<code>a</code>。</p>
<p>由于ASCII编码表只制定了1个字节的对应关系，但是，中文的汉字种类太多，1个字节无法表达，就需要更多的字节数，例如使用2个字节，就可以表示更多种对应关系，Java语言在处理字符时，内存中就使用的Unicode编码。</p>
<p>当数据需要传输时，如果传输的是<code>a</code>，只需要1个字节就够了，如果传输的是<code>中</code>这个汉字，至少需要2个字节，所以，如果单纯直接传输二进制数的序列，接收方可能接收到<code>1110 0001 1101 1100 1011 1010</code>，却不知道如何进行分隔！所以，为了保证能够正确的分隔这些二进制的序列，就产生了传输编码，例如UTF-8。</p>
<p>在UTF-8中，如果某个字符是2个字节的，则使用的格式是：</p>
<pre><code>110x xxxx	10xx xxxx
</code></pre>
<p>如果某个字符是3个字节的，则使用的格式是：</p>
<pre><code>1110 xxxx	10xx xxxx	10xx xxxx
</code></pre>
<p>如果某个字符是4个字节的，则使用的格式是：</p>
<pre><code>1111 0xxx	10xx xxxx	10xx xxxx	10xx xxxx
</code></pre>
<p>通常，UTF-8分为常用版本(utf8mb3)和包括了不常用字符的版本(utf8mb4)，一般默认指的是常用版本。</p>
<p>当然，除了UTF-8以外，还有其它的编码格式，例如GBK、GB2312、ISO-8859-1、latin1等，不同的编码格式的编码规范是不相同的，甚至有些编码格式并不支持中文！所以，如果发出和接收使用的是不同的编码，甚至使用了不支持中文的编码，就会导致无法解读，进而出现乱码！</p>
<p>所以，乱码问题都是由于“使用的编码不统一”所导致的，而解决方案就是“使用统一的编码”，在项目中，常见的需要指定编码的位置有：项目的源代码、网络传输和接收的编码、界面、其它网络连接、数据库等存储位置……可以简单的理解为：只要能够指定编码的位置，统统指定同一种编码，就不会出现乱码，如果没有指定，就可能出现乱码。</p>
]]></content>
    </entry>
</feed>